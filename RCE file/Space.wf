{
  "identifier" : "1454b3f4-442f-4a66-92cd-a93c52dce469",
  "workflowVersion" : "5",
  "name" : "Space.wf",
  "nodes" : [ {
    "identifier" : "1cdae4e7-38e3-4280-9af1-08d83e0bc98d",
    "name" : "Cost_input_filter",
    "location" : "3405:2070",
    "zIndex" : "49",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage/Engines/Liquid |\n\t\t\t/Rocket/Stage/Engines/Solid |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Mass\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage/Engines/Liquid |\n\t\t\t/Rocket/Stage/Engines/Solid |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Mass\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "4c8ee6c3-efde-4318-9144-76ba260f9b58",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "552b2525-108b-41d2-9dc2-174e420dddc7",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "7e5fad76-db22-4785-af69-2630e8551fce",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "b6a60a36-cdf6-46a4-8fee-d99e2a7a8e69",
    "name" : "Cost_merge_script",
    "location" : "3570:2140",
    "zIndex" : "51",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "0b4cacf4-f4e6-43ae-8557-32eaaa5a8a7a",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "09ce04ea-cf32-45e5-96be-8e63a33fad1e",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "2b1e45f7-4082-40e2-ae7a-c1ec8bdcfe75",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "686d0676-b5a2-4d2f-965d-70430c05c0ae",
    "name" : "Cost_output_filter",
    "location" : "3495:2160",
    "zIndex" : "50",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Cost\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Cost\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "c7134c1b-c1e0-46f8-973c-b9df080ad2dc",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "8e4c99a7-7a48-453f-ac9b-182ade78cc79",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "e26b42a8-c227-45b3-9e9b-6fc9b375c309",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "853f4bc7-9755-436f-8bcc-49a54b73b2e8",
    "name" : "Cost_splitter",
    "location" : "3475:2070",
    "zIndex" : "52",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlvalues",
      "version" : "1.0",
      "name" : "XML Values"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "b8463e3e-b330-42a7-bd8b-bb2d9e5f5756",
      "name" : "XML",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "dcb63aad-db87-4dca-86fc-84317628700a",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "29db3508-b008-41be-9e4b-573cdd7a0b86",
    "name" : "Engine_solid_space",
    "location" : "885:740",
    "zIndex" : "63",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Engine_solid_space",
      "version" : "1.0",
      "name" : "Engine_solid_space"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "3b59d896-4207-4382-b094-3a46c614362b",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "9fd00567-d257-438b-98ad-0d73727dd17c",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "741f1116-ab7f-4d44-8df2-3090113fdfce",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "96175205-e108-45cc-aa13-5d3b60e0fab1",
    "name" : "Geom_input_filter",
    "location" : "1555:1100",
    "zIndex" : "22",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Geometry/Cone_angle |\n\t\t\t/Rocket/Geometry/Head_shape |\n\t\t\t/Rocket/Geometry/L_D |\n\t\t\t/Rocket/Geometry/L_ratio_ellipse |\n\t\t\t/Rocket/Stage/Engines/Liquid |\n\t\t\t/Rocket/Stage/Engines/Solid |\n\t\t\t/Rocket/Stage/Geometry/Length\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Geometry/Cone_angle |\n\t\t\t/Rocket/Geometry/Head_shape |\n\t\t\t/Rocket/Geometry/L_D |\n\t\t\t/Rocket/Geometry/L_ratio_ellipse |\n\t\t\t/Rocket/Stage/Engines/Liquid |\n\t\t\t/Rocket/Stage/Engines/Solid |\n\t\t\t/Rocket/Stage/Geometry/Length\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "5fd00b10-4283-4b62-a8a4-016a00909b33",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "ce848114-0c77-41d8-a09a-3017885794e5",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "65588f44-f3fd-44c6-8360-9274638e8e77",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "9ce122ac-53d5-4da7-8253-953f880883ee",
    "name" : "Geom_merge_script",
    "location" : "1720:1170",
    "zIndex" : "24",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "cb59480f-a9e4-4a3b-bdfc-a1f5fd89b889",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "eec14963-bce3-4eb0-a094-56ab98e0a969",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "a75ad1a3-f0f4-45de-812a-bc9acabbe00c",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "9a147e3b-2160-418a-9edb-1d5dda7e137f",
    "name" : "Geom_output_filter",
    "location" : "1645:1190",
    "zIndex" : "23",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Geometry/Diameter |\n\t\t\t/Rocket/Payload/Available_volume |\n\t\t\t/Rocket/Stage/Geometry/Fuel_tank_surface |\n\t\t\t/Rocket/Stage/Geometry/Fuel_tank_volume |\n\t\t\t/Rocket/Stage/Geometry/Head_surface |\n\t\t\t/Rocket/Stage/Geometry/Oxidizer_tank_surface |\n\t\t\t/Rocket/Stage/Geometry/Oxidizer_tank_volume |\n\t\t\t/Rocket/Stage/Geometry/Stage_volume\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Geometry/Diameter |\n\t\t\t/Rocket/Payload/Available_volume |\n\t\t\t/Rocket/Stage/Geometry/Fuel_tank_surface |\n\t\t\t/Rocket/Stage/Geometry/Fuel_tank_volume |\n\t\t\t/Rocket/Stage/Geometry/Head_surface |\n\t\t\t/Rocket/Stage/Geometry/Oxidizer_tank_surface |\n\t\t\t/Rocket/Stage/Geometry/Oxidizer_tank_volume |\n\t\t\t/Rocket/Stage/Geometry/Stage_volume\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "7131446c-6481-499c-8e9d-374daeb409a1",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "253b7245-fdc5-45b4-a7ea-a371cc93c9fd",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "3f01866d-c8a0-4076-9851-bd9249c5d80b",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "dbe88bec-d81c-4a27-8448-42f1900b5dd6",
    "name" : "Geom_splitter",
    "location" : "1625:1100",
    "zIndex" : "25",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlvalues",
      "version" : "1.0",
      "name" : "XML Values"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "2f8d6fc9-4c5c-47ba-81d9-9439d751e4ff",
      "name" : "XML",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "b0d86ef1-a41c-43db-a3ea-2506719d5c85",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "c1cfc5a0-a5e1-447e-985f-d8ee2192ad6d",
    "name" : "Input Provider",
    "location" : "-309:-12",
    "zIndex" : "71",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.inputprovider",
      "version" : "3.2",
      "name" : "Input Provider"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "dynamicOutputs" : [ {
      "identifier" : "d4c0c5c6-f74b-48c3-b4b4-445cb7fdd2ab",
      "name" : "File",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "startValue" : "Space/3stages.xml"
      }
    } ]
  }, {
    "identifier" : "7d0bc860-c353-46da-980b-26ffb474d50f",
    "name" : "Liq_prop_activation_logic",
    "location" : "255:60",
    "zIndex" : "4",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# This script is used in order to determine if a tool has to be activated or not.\n# To achieve that, what is done is to check the assertion expressing the condition for the\n# activation of the tool.\n# In case that the assertion is true, then the boolean called statement is True, in the opposite\n# case it will be false, disactivating the tool\n\n# Code is original\n\nimport os\nimport re\nimport time\nimport random\nimport glob\nfrom xml.etree import ElementTree as et\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n\n\ndef check_activation_logic(tool_activation_logic):\n    # The reference file is read\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n    activation = tool_activation_logic.do_assert(architecture_file)    # Assertion is checked\n\n\n    # XML and statement\n    root = et.parse(base_path_renamed).getroot()\n    tree = et.ElementTree(root)\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n    RCE.write_output(\"statement\", activation)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\n#tool_activation_logic is inputted here\ntool_activation_logic = XPathExists('/Rocket/Stage/Engines/Liquid/VULCAIN') | XPathExists('/Rocket/Stage/Engines/Liquid/RS68') | XPathExists('/Rocket/Stage/Engines/Liquid/SIVB')\n\n#Assertion is checked\ncheck_activation_logic(tool_activation_logic)",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "48a611bf-53de-4a00-bdbd-381988303ef3",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "cb6dc3e3-de01-4531-a9c3-e5f888e72b9f",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "3214a7a2-118f-499e-9192-f8a73056b72b",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "e3076cb2-12d3-4c1c-9125-be8a29b7dba2",
    "name" : "Liq_prop_global_to_local",
    "location" : "350:220",
    "zIndex" : "9",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n   # Might be all or just some depending on the case scenario\nclass NumberofInstances(XPathAssertion):\n\n    \"\"\"Determines the number of child nodes with a certain tag\"\"\"\n\n\n\n    def __init__(self, xpath, instance):\n\n        super(NumberofInstances, self).__init__(xpath)\n\n        self._instance = instance\n\n\n\n    def _assert(self, els):\n\n        instance = self._instance\n\n        counter = 0\n\n        for element in els:\n\n            counter = counter + len(element.findall(instance))\n\n        return counter\n\n\n\n    def __repr__(self):\n\n        return \"{class_name}('{xpath}', '{instance}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, instance=self._instance)\n\n\n\n\n\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n    if isinstance(assertion_repetition,int):\n        number_of_repetitions = assertion_repetition\n    else:\n        number_of_repetitions = assertion_repetition.do_assert(architecture_file)    # Assertion is checked\n\n    xpath_in = ['/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/SIVB', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/VULCAIN', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/RS68']\n    xpath_out = ['/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Expansion_ratio', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Thrust', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/mdot']\n\n\n    # It is needed to know at what iteration the workflow is\n    index = RCE.read_state_variable (\"iteration\")\n    if index is None:\n        index = 1\n\n    index_iter = RCE.read_state_variable (\"index_iteration\")\n    if index_iter is None:\n        index_iter = 1\n\n    tool_activation_logic = XPathExists('/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/VULCAIN') | XPathExists('/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/RS68') | XPathExists('/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/SIVB')\n    activation_str = repr(tool_activation_logic)\n    flag = 0\n    while flag == 0:\n        if \"INDEX\" in activation_str:\n            tool_activation_logic = parse_expression(activation_str.replace(\"{INDEX}\", str(index)))\n        activation = tool_activation_logic.do_assert(architecture_file)\n        if activation == True:\n            flag = 1\n        else:\n            index = index + 1\n\n\n\n\n\n\n\n    xpaths_output = []\n    values_output = []\n    keys_output = []\n\n    # Inputs are iterated before outputs. Changes to the workflow xml are introduced here. These are the uid tags rename\n    for xpath in xpath_in:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            xpath_to_search_no_number = re.findall(r\".*{INDEX}.*?/\", xpath_no_root)[0][:-1]\n            xpath_check = xpath_to_search_no_number.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n\n\n            try:  # Might have been changed already before\n                root.find(xpath_check).attrib[key_repetition] = value_index\n            except:\n                pass\n\n    for xpath in xpath_out:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            value_repetition = value_index.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n            xpath_to_save_repetition = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0]\n            xpath_for_rest_of_attributes = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0] + re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[1]\n            if \"@\" in xpath_to_save_repetition:\n                attributes = re.findall(\"\\[@.*?]\", xpath_for_rest_of_attributes)\n                xpath_iteration = xpath_for_rest_of_attributes\n                for element in attributes:\n                    keys_output.append(re.search(\"@([^=]+)=\", element).group(1))\n                    values_output.append(re.search('@[^=]+=\"([^\"]+)\"', element).group(1))\n                    xpath_split = re.split(\"\\[@.*?]\", xpath_iteration, 1)\n                    xpaths_output.append(xpath_split[0])\n                    xpath_iteration = xpath_split[0] + xpath_split[1]\n\n\n            keys_output.append(key_repetition)\n            values_output.append(value_repetition)\n            xpaths_output.append(xpath_to_save_repetition)\n\n\n    input_file = RCE.create_input_file()\n    file = input_file.write_to_file(\"g_l\")\n\n    f = open(file, 'w')\n    f.write(str(xpaths_output) + \"\\n\")\n    f.write(str(keys_output) + \"\\n\")\n    f.write(str(values_output) + \"\\n\")\n    f.write (str(number_of_repetitions))\n    RCE.write_output(\"xpaths_uids\", file)\n    if index_iter == number_of_repetitions:\n        RCE.write_state_variable (\"iteration\", 1)\n        RCE.write_state_variable (\"index_iteration\", 1)\n    else:\n        RCE.write_state_variable (\"iteration\", index+1)\n        RCE.write_state_variable (\"index_iteration\", index_iter+1)\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = NumberofInstances('/Rocket/Stage/Engines', 'Liquid')\ndeactivation_logic = None\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "42c41f14-a8c4-4940-a71c-cdd7f45a8897",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "50bbdec3-fc53-47d2-96cb-754f033ba0bb",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "f16d562f-37ed-4069-95d9-c6d1bd3a8a87",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "4a2c578a-dcdf-4bab-a6b1-dae791159ab6",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "3473d476-500d-42d8-bf66-c57b34b20f9b",
    "name" : "Liq_prop_input_filter",
    "location" : "255:240",
    "zIndex" : "0",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Liquid\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Liquid\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "4ea3725b-fa9d-4f32-92e4-2af0186898a9",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "7730ba2f-ef4d-490c-a2c4-fa6d2e1e75a7",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "99318140-d992-474e-9a5b-4819d04eac87",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "1041e708-0e55-474f-9b1c-8a9f6321a884",
    "name" : "Liq_prop_iterator",
    "location" : "720:310",
    "zIndex" : "6",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "import re\n\n\nindex = RCE.read_state_variable (\"iteration\")\nif index is None:\n    index = 1    # Iterations finished\n\n\nbase_path = RCE.read_input(\"XML\")\n\ntry:\n    file_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\n    with open(file_xpaths_uids, \"r\") as f:\n        lines = f.readlines()\n\n    repetitions = int(lines[3])\nexcept:    # This is a zero run loop in case of repetition plus activation\n    repetitions = 1\n\nRCE.write_output(\"XML\", base_path)\n\n\nif index == repetitions:\n    RCE.write_output(\"statement\", True)\n    RCE.write_state_variable (\"iteration\",1)\r\n    RCE.close_all_outputs()\nelse:\n    RCE.write_output(\"statement\", False)\n    RCE.write_state_variable (\"iteration\",index+1)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "d64a8fa7-0f48-4619-a828-9750452d4fdf",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "e2481978-1a9b-4649-a108-baf69e6dd206",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "NotRequired",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "f5c77d24-973d-4579-b3ba-1f8ca2b1628d",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "0061c544-a7e9-41d7-a79e-6c95a0bfad7f",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "30eab269-13f4-418f-b14e-a2a11e29c40c",
    "name" : "Liq_prop_joiner_activation",
    "location" : "645:330",
    "zIndex" : "5",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "42cbe51c-99dd-4d00-95d3-9ccdbcc7d173",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "01a31dec-11cb-44e8-aebe-30e87cc4c8c9",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "da9bc352-81ad-4045-ba07-ea680f7060a6",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "50f7364c-cb60-4c22-a158-70b5faf606ef",
    "name" : "Liq_prop_joiner_repetition",
    "location" : "370:150",
    "zIndex" : "8",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "3fcedc7a-8a5c-41c2-bbfe-e7763193be83",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "b7e9346a-714f-4c1b-8ea9-6388d9571340",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "108f8cc5-8572-4133-ad26-cb97ec5ffe6f",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "29d1c39c-85b5-4a95-b7a5-d8d9cc455eea",
    "name" : "Liq_prop_local_to_global",
    "location" : "420:310",
    "zIndex" : "10",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport os\nimport ast\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nbase_path = RCE.read_input(\"XML\")\n# Rename input file, otherwise RCE will not update input files in subsequent script executions\nbase_path_renamed = random_rename(base_path)\nos.rename(base_path, base_path_renamed)\n\n# XML and statement\ntree = et.parse(base_path_renamed)\nroot = tree.getroot()\n\n# We read the list of outputs and their uids.\n\nfile_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\nwith open(file_xpaths_uids, \"r\") as f:\n    lines = f.readlines()\n\nxpaths_output = ast.literal_eval(lines[0])\nkeys_output = ast.literal_eval(lines[1])\nvalues_output = ast.literal_eval(lines[2])\n\nfor i in range(len(xpaths_output)):\n     xpath = xpaths_output[i]\n     key = keys_output[i]\n     value = values_output[i]\n     root.find(xpath).set(key, value)\n\n\n# Output xml\noutput_path = random_rename(base_path, same_path=False)\nf_base = open(output_path, \"wb\")\ntree.write(f_base, encoding=\"utf-8\")\nf_base.close()\nRCE.write_output(\"XML\", output_path)\n\ndef random_rename(file_path, same_path=True):\n    file_name, file_ext = os.path.splitext(file_path)\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "af7de67f-13f7-497f-a768-799c9ad59629",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "8af7db8e-2ed6-42ee-b2cc-7c4d134804df",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "e0b5b8d9-728d-48d2-b9aa-f223d262c37f",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "c92c9604-10d6-4977-8354-eae9d089845e",
    "name" : "Liq_prop_merge_script",
    "location" : "535:310",
    "zIndex" : "2",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "4f9d0d6c-bdd6-48a6-8619-e388ed037980",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "a42daa3f-75e8-47b1-9681-6e063e78c727",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "7cf93e22-3c1c-4ff1-972b-2807f55c4f7c",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "a9f4d5bd-18ae-48c3-8ddc-7b8b352b002f",
    "name" : "Liq_prop_output_filter",
    "location" : "345:330",
    "zIndex" : "1",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage/Engines/Expansion_ratio |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage/Engines/Expansion_ratio |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "305a4ea7-7aa5-4da8-a021-fbba7b9b39bf",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "d02a3995-91ea-487e-96d0-7aebdc727a37",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "a44d931b-994c-4eab-87f7-52bc4c553060",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "65a76d99-e481-4589-807b-cfea451d5988",
    "name" : "Liq_prop_repetition_switch",
    "location" : "830:330",
    "zIndex" : "7",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "e38d3bdc-c99b-4eda-b8f1-40ff091ec844",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "2d58ba5d-b9b5-454f-b765-5ab26ca4963d",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "86785fbb-d099-41ee-933c-b3a8420e1491",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "34f171b3-cd46-4120-be79-57ad51f039eb",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "b46467c3-7e3a-4755-898f-9f2e8bcd30ce",
    "name" : "Liq_prop_switch_activation",
    "location" : "370:80",
    "zIndex" : "3",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "74afcd5b-09f4-447e-b4bd-2ce553bce4ac",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "bee82a36-a0dc-48e9-b4c6-94344a95311a",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "976c6325-613e-4850-90ad-c26486f4fac2",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "56bb506e-8dd2-4158-8a9a-f77e5587d8c9",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "c76e947d-ff6f-4e0d-ac87-afd1276c4b1a",
    "name" : "Liqud_engine_space",
    "location" : "235:310",
    "zIndex" : "62",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Liqud_engine_space",
      "version" : "1.0",
      "name" : "Liqud_engine_space"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "452f414e-bb18-40eb-8f81-3252e52e4e78",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "fe5e2ed0-de22-4baf-bd09-b19e2745dfb3",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "24570824-b0a1-46ad-930e-c7f0d8ec99d1",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "9618781c-edc6-4642-b560-5d05a82f8ab2",
    "name" : "Merger",
    "location" : "4552:2500",
    "zIndex" : "61",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from lxml import etree\r\nimport time\r\nimport random\r\nimport glob\r\nimport os\r\nimport re\r\n\r\n\r\ndef random_rename(file_path, same_path=True):\r\n    file_name_0, file_ext = os.path.splitext(file_path)\r\n    file_name = re.split(\"_renamed\", file_name_0)[0]\r\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\r\n        int(random.randint(0, 1000000))) + file_ext\r\n    if not same_path:\r\n        return renamed_file\r\n    return os.path.join(os.path.dirname(file_path), renamed_file)\r\n\r\ndef Compiler():\r\n\r\n\r\n\r\n    main_file = RCE.read_input(\"Main_file\")\r\n    cost_file = RCE.read_input(\"Cost_file\")\r\n    payload_file = RCE.read_input(\"Payload_file\")\r\n\r\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\r\n    main_file_renamed = random_rename(main_file)\r\n    cost_file_renamed = random_rename(cost_file)\r\n    payload_file_renamed = random_rename(payload_file)\r\n\r\n    os.rename(main_file, main_file_renamed)\r\n    os.rename(cost_file, cost_file_renamed)\r\n    os.rename(payload_file, payload_file_renamed)\r\n\r\n\r\n    # XML and statement\r\n    tree_main_file = etree.parse(main_file_renamed)\r\n    tree_cost_file = etree.parse(cost_file_renamed)\r\n    tree_payload_file = etree.parse(payload_file_renamed)\r\n\r\n    root_main_file = tree_main_file.getroot()\r\n    root_cost_file = tree_cost_file.getroot()\r\n    root_payload_file = tree_payload_file.getroot()\r\n\r\n\r\n    cost_tree = etree.SubElement(root_main_file, \"Cost\")\r\n    constraint_c = etree.SubElement(cost_tree, \"Total_cost\")\r\n    constraint_c.text = root_cost_file.xpath(\"Cost/Total_cost/text()\")[0]\r\n\r\n\r\n    pay_tree = root_main_file.xpath(\"Payload\")[0]\r\n    constraint_p = etree.SubElement(pay_tree, \"Constraint\")\r\n    constraint_p.text = root_payload_file.xpath(\"Payload/Constraint/text()\")[0]\r\n\r\n    output_path = random_rename(main_file, same_path=False)\r\n    f_base = open(output_path, \"wb\")\r\n    tree_main_file.write(f_base, encoding=\"utf-8\")\r\n    f_base.close()\r\n    RCE.write_output(\"Opt_result\", output_path)\r\n\r\n\r\n\r\nCompiler()",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "1d3b9346-c6f5-4553-a841-60a5a65ec623",
      "name" : "Cost_file",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "0f9d4f88-249c-4c66-876d-489b08d2e223",
      "name" : "Main_file",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "5fbc4438-b1e3-46b5-bba7-3bb3da415329",
      "name" : "Payload_file",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "bacd15b7-18c1-4802-a92c-397d6d4db59b",
      "name" : "Opt_result",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "baa70859-781d-4281-9177-450bc5a0d891",
    "name" : "Obj_Output_Writer",
    "location" : "4716:2520",
    "zIndex" : "72",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.outputwriter",
      "version" : "2.1",
      "name" : "Output Writer"
    },
    "configuration" : {
      "OWWritePath" : "${targetRootFolder}",
      "SelectRootOnWorkflowStart" : "true",
      "SelectedRoot" : "",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "09ad99b7-f864-4a80-9a81-e7e13950267c",
      "name" : "XML",
      "epIdentifier" : "default",
      "group" : "write",
      "datatype" : "FileReference",
      "metadata" : {
        "filename" : "[Timestamp at workflow start]__[Workflow name]__[Execution count].xml",
        "folderForSaving" : "[root]"
      }
    } ],
    "dynamicInputGroups" : [ {
      "name" : "2bfe07e3-b97f-4fa1-9baf-a41edc1f6f8b",
      "epIdentifier" : "dynamicAndGroup"
    } ]
  }, {
    "identifier" : "2661aee0-700d-4dbb-825a-1f84ff27be47",
    "name" : "Pay_const_input_filter",
    "location" : "4205:2430",
    "zIndex" : "57",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Payload/Available_volume |\n\t\t\t/Rocket/Payload/Density |\n\t\t\t/Rocket/Payload/Mass\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Payload/Available_volume |\n\t\t\t/Rocket/Payload/Density |\n\t\t\t/Rocket/Payload/Mass\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "e2d81ff7-c049-40e1-9c1e-165b88c02dbc",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "fed07c1f-3bd0-42c9-899f-fd55e82e5479",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "f616c728-b953-43f8-8922-a4ba3a947814",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "470b1407-d49a-4abc-b5cd-175792a6cf1a",
    "name" : "Pay_const_merge_script",
    "location" : "4370:2500",
    "zIndex" : "59",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "bc0be9a2-317e-4665-b710-70bdc19a7381",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "41ba5dbe-7b5b-4c1e-b028-ee742fd12acf",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "c134740b-ebdb-4abd-8815-ae4339f2785b",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "ad442ee6-86e8-413e-8919-953c5c196a42",
    "name" : "Pay_const_output_filter",
    "location" : "4295:2520",
    "zIndex" : "58",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Payload/Constraint\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Payload/Constraint\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "a32727d1-ce5d-43c2-a039-fb13fecc3e2b",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "e2095afc-1778-4b19-8118-6555af3d58fa",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "4da09d3a-20e9-419f-a279-d5a9ba412a32",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "cb9573d4-d7c6-4dbf-85b6-edfb7c5f6742",
    "name" : "Pay_const_splitter",
    "location" : "4275:2430",
    "zIndex" : "60",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlvalues",
      "version" : "1.0",
      "name" : "XML Values"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "158a1808-a767-4c98-9b76-e40614dc6ba5",
      "name" : "XML",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "bae03932-3849-42b1-8ad8-beda248000a2",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "febde8aa-49f8-4058-85d6-fb6659f0149b",
    "name" : "Prop_mass_global_to_local",
    "location" : "2050:1260",
    "zIndex" : "32",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nclass Assertion(object):\n\n\n\n    def do_assert(self, arch):\n\n        raise NotImplementedError\n\n\n\n    def __invert__(self):  # \"not\" operator ~\n\n        return NotAssertion(self)\n\n\n\n    def __and__(self, other):  # \"and\" operator &\n\n        if not isinstance(other, Assertion):\n\n            raise NotImplementedError\n\n        return AndAssertion(self, other)\n\n\n\n    def __or__(self, other):  # \"or\" operator |\n\n        if not isinstance(other, Assertion):\n\n            raise NotImplementedError\n\n        return OrAssertion(self, other)\n\n\n\n    def __xor__(self, other):  # \"xor\" operator ^\n\n        if not isinstance(other, Assertion):\n\n            raise NotImplementedError\n\n        return XorAssertion(self, other)\n\n\n\n    def __repr__(self):\n\n        raise NotImplementedError\n\n\n\n\n\nclass XPathAssertion(Assertion):\n\n\n\n    def __init__(self, xpath):\n\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n\n\n    def do_assert(self, arch):\n\n        return self._assert(arch.get_elements(self._xpath))\n\n\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n\n        raise NotImplementedError\n\n\n\n    def __repr__(self):\n\n        raise NotImplementedError\n\n\n\n\n   # Might be all or just some depending on the case scenario\nclass NumberofInstances(XPathAssertion):\n\n    \"\"\"Determines the number of child nodes with a certain tag\"\"\"\n\n\n\n    def __init__(self, xpath, instance):\n\n        super(NumberofInstances, self).__init__(xpath)\n\n        self._instance = instance\n\n\n\n    def _assert(self, els):\n\n        instance = self._instance\n\n        counter = 0\n\n        for element in els:\n\n            counter = counter + len(element.findall(instance))\n\n        return counter\n\n\n\n    def __repr__(self):\n\n        return \"{class_name}('{xpath}', '{instance}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, instance=self._instance)\n\n\n\n\n\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n    if isinstance(assertion_repetition,int):\n        number_of_repetitions = assertion_repetition\n    else:\n        number_of_repetitions = assertion_repetition.do_assert(architecture_file)    # Assertion is checked\n\n    xpath_in = ['/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Stage_volume', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Oxidizer_tank_volume', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/SIVB', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/VULCAIN', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/RS68', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/SRB', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Fuel_tank_volume', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/P80', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/GEM60']\n    xpath_out = ['/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/LOX', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Propellant', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Hydrogen']\n\n\n    # It is needed to know at what iteration the workflow is\n    index = RCE.read_state_variable (\"iteration\")\n    if index is None:\n        index = 1\n\n    index_iter = RCE.read_state_variable (\"index_iteration\")\n    if index_iter is None:\n        index_iter = 1\n\n\n\n    xpaths_output = []\n    values_output = []\n    keys_output = []\n\n    # Inputs are iterated before outputs. Changes to the workflow xml are introduced here. These are the uid tags rename\n    for xpath in xpath_in:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            xpath_to_search_no_number = re.findall(r\".*{INDEX}.*?/\", xpath_no_root)[0][:-1]\n            xpath_check = xpath_to_search_no_number.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n\n\n            try:  # Might have been changed already before\n                root.find(xpath_check).attrib[key_repetition] = value_index\n            except:\n                pass\n\n    for xpath in xpath_out:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            value_repetition = value_index.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n            xpath_to_save_repetition = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0]\n            xpath_for_rest_of_attributes = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0] + re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[1]\n            if \"@\" in xpath_to_save_repetition:\n                attributes = re.findall(\"\\[@.*?]\", xpath_for_rest_of_attributes)\n                xpath_iteration = xpath_for_rest_of_attributes\n                for element in attributes:\n                    keys_output.append(re.search(\"@([^=]+)=\", element).group(1))\n                    values_output.append(re.search('@[^=]+=\"([^\"]+)\"', element).group(1))\n                    xpath_split = re.split(\"\\[@.*?]\", xpath_iteration, 1)\n                    xpaths_output.append(xpath_split[0])\n                    xpath_iteration = xpath_split[0] + xpath_split[1]\n\n\n            keys_output.append(key_repetition)\n            values_output.append(value_repetition)\n            xpaths_output.append(xpath_to_save_repetition)\n\n\n    input_file = RCE.create_input_file()\n    file = input_file.write_to_file(\"g_l\")\n\n    f = open(file, 'w')\n    f.write(str(xpaths_output) + \"\\n\")\n    f.write(str(keys_output) + \"\\n\")\n    f.write(str(values_output) + \"\\n\")\n    f.write (str(number_of_repetitions))\n    RCE.write_output(\"xpaths_uids\", file)\n    if index_iter == number_of_repetitions:\n        RCE.write_state_variable (\"iteration\", 1)\n        RCE.write_state_variable (\"index_iteration\", 1)\n    else:\n        RCE.write_state_variable (\"iteration\", index+1)\n        RCE.write_state_variable (\"index_iteration\", index_iter+1)\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = NumberofInstances('/Rocket', 'Stage')\ndeactivation_logic = None\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "51268cbf-82b9-4ada-9d68-a0fa69368d2d",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "9c8922fd-5c47-4333-b675-7d152635660f",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "23ea43ca-4dbe-4f78-9b57-44de6812c5c4",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "c75ca9f4-ff03-418e-96ef-36262962d231",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "a1c1d9f4-f675-4ff3-9945-2ffc6b6de994",
    "name" : "Prop_mass_input_filter",
    "location" : "1955:1280",
    "zIndex" : "26",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Liquid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Solid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Fuel_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Oxidizer_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Stage_volume\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Liquid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Solid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Fuel_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Oxidizer_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Stage_volume\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "268ad63f-b2ba-41a0-b905-d4110928c494",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "edea557f-3459-48ab-b87f-614e63d600c8",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "5d8c0988-e99f-4591-85fa-6a9c816c9d10",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "55eae39a-1f06-44f4-9610-e4373b955c23",
    "name" : "Prop_mass_iterator",
    "location" : "2350:1350",
    "zIndex" : "29",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "import re\n\n\nindex = RCE.read_state_variable (\"iteration\")\nif index is None:\n    index = 1    # Iterations finished\n\n\nbase_path = RCE.read_input(\"XML\")\n\ntry:\n    file_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\n    with open(file_xpaths_uids, \"r\") as f:\n        lines = f.readlines()\n\n    repetitions = int(lines[3])\nexcept:    # This is a zero run loop in case of repetition plus activation\n    repetitions = 1\n\nRCE.write_output(\"XML\", base_path)\n\n\nif index == repetitions:\n    RCE.write_output(\"statement\", True)\n    RCE.write_state_variable (\"iteration\",1)\r\n    RCE.close_all_outputs()\nelse:\n    RCE.write_output(\"statement\", False)\n    RCE.write_state_variable (\"iteration\",index+1)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "cbe64f41-eece-4736-be82-cd26a6f502eb",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "333ddf92-b005-4ccb-8d81-4423e0a3d7ec",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "NotRequired",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "54643253-d01f-40e7-b96a-f2e5bacf21c1",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "6b1fb1ac-ad9d-4a68-8e6a-ca47ece2aa56",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "d0b5d7c3-158f-4abd-a900-598e93943d17",
    "name" : "Prop_mass_joiner_repetition",
    "location" : "2070:1190",
    "zIndex" : "31",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "c45ac4ac-4ea8-428a-8727-5bd99a164c9b",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "0ac6e61f-a54c-4dda-a958-a2c85c546df6",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "7953c7a2-bcbf-461f-af6e-2c82e070e949",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "338e2fa0-d23f-47b3-a443-04a5ccf92b94",
    "name" : "Prop_mass_local_to_global",
    "location" : "2120:1350",
    "zIndex" : "33",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport os\nimport ast\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nbase_path = RCE.read_input(\"XML\")\n# Rename input file, otherwise RCE will not update input files in subsequent script executions\nbase_path_renamed = random_rename(base_path)\nos.rename(base_path, base_path_renamed)\n\n# XML and statement\ntree = et.parse(base_path_renamed)\nroot = tree.getroot()\n\n# We read the list of outputs and their uids.\n\nfile_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\nwith open(file_xpaths_uids, \"r\") as f:\n    lines = f.readlines()\n\nxpaths_output = ast.literal_eval(lines[0])\nkeys_output = ast.literal_eval(lines[1])\nvalues_output = ast.literal_eval(lines[2])\n\nfor i in range(len(xpaths_output)):\n     xpath = xpaths_output[i]\n     key = keys_output[i]\n     value = values_output[i]\n     root.find(xpath).set(key, value)\n\n\n# Output xml\noutput_path = random_rename(base_path, same_path=False)\nf_base = open(output_path, \"wb\")\ntree.write(f_base, encoding=\"utf-8\")\nf_base.close()\nRCE.write_output(\"XML\", output_path)\n\ndef random_rename(file_path, same_path=True):\n    file_name, file_ext = os.path.splitext(file_path)\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "1c19d1bc-dab6-4b07-b1e8-4dc87a71a956",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "47b57c19-9543-4827-a47f-030c2a8fde5b",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "8bbe6a46-8684-4450-975c-51b1e3b9fb2b",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "cbd6a42e-7d06-4d00-821e-b1f4345f5efe",
    "name" : "Prop_mass_merge_script",
    "location" : "2235:1350",
    "zIndex" : "28",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "dc304b35-c94f-468f-9a1a-cabadce6cac1",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "a8e5059d-236e-440b-ad22-f47fcaa0dca4",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "0949b926-db4b-4e16-9e70-7456304098dd",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "6cce1e36-5c73-4e91-b055-a56e65c1d763",
    "name" : "Prop_mass_output_filter",
    "location" : "2045:1370",
    "zIndex" : "27",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage/Mass/Hydrogen |\n\t\t\t/Rocket/Stage/Mass/LOX |\n\t\t\t/Rocket/Stage/Mass/Propellant\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage/Mass/Hydrogen |\n\t\t\t/Rocket/Stage/Mass/LOX |\n\t\t\t/Rocket/Stage/Mass/Propellant\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "f9ae8ba7-0da9-488f-889f-97c90bd07aee",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "5c0a234d-b0e9-4f2f-98bb-3658011f401c",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "3a5df8b1-4fbb-4d30-8404-5a11f062b88d",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "663c60f4-2fea-45f8-88b0-1bc2dbd65bf7",
    "name" : "Prop_mass_repetition_switch",
    "location" : "2460:1370",
    "zIndex" : "30",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "bb382031-2cfe-4cca-a7f2-6792b409d699",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "dc2d3235-9aad-410b-bb8b-4ddd50d8ed0d",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "69d3fe20-2f14-4967-b1c1-64f2cefb1366",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "31b7fc28-bfc3-4a50-b491-1d7f3dd8fbef",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "55974baf-3717-428b-ab7b-e0ddb3c75a05",
    "name" : "Sol_prop_activation_logic",
    "location" : "905:490",
    "zIndex" : "15",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# This script is used in order to determine if a tool has to be activated or not.\n# To achieve that, what is done is to check the assertion expressing the condition for the\n# activation of the tool.\n# In case that the assertion is true, then the boolean called statement is True, in the opposite\n# case it will be false, disactivating the tool\n\n# Code is original\n\nimport os\nimport re\nimport time\nimport random\nimport glob\nfrom xml.etree import ElementTree as et\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n\n\ndef check_activation_logic(tool_activation_logic):\n    # The reference file is read\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n    activation = tool_activation_logic.do_assert(architecture_file)    # Assertion is checked\n\n\n    # XML and statement\n    root = et.parse(base_path_renamed).getroot()\n    tree = et.ElementTree(root)\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n    RCE.write_output(\"statement\", activation)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\n#tool_activation_logic is inputted here\ntool_activation_logic = XPathExists('/Rocket/Stage/Engines/Solid/SRB') | XPathExists('/Rocket/Stage/Engines/Solid/P80') | XPathExists('/Rocket/Stage/Engines/Solid/GEM60')\n\n#Assertion is checked\ncheck_activation_logic(tool_activation_logic)",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "4aad0149-fb6c-470a-bdca-60ae198bbd30",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "8e7cec3b-b1fe-4578-ba0e-a303e50b7be9",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "31fc15a0-71dd-44a5-9f9f-890ae005c9ad",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "306c57dc-d731-43c6-a59e-959ae5d41f34",
    "name" : "Sol_prop_global_to_local",
    "location" : "1000:650",
    "zIndex" : "20",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n   # Might be all or just some depending on the case scenario\nclass NumberofInstances(XPathAssertion):\n\n    \"\"\"Determines the number of child nodes with a certain tag\"\"\"\n\n\n\n    def __init__(self, xpath, instance):\n\n        super(NumberofInstances, self).__init__(xpath)\n\n        self._instance = instance\n\n\n\n    def _assert(self, els):\n\n        instance = self._instance\n\n        counter = 0\n\n        for element in els:\n\n            counter = counter + len(element.findall(instance))\n\n        return counter\n\n\n\n    def __repr__(self):\n\n        return \"{class_name}('{xpath}', '{instance}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, instance=self._instance)\n\n\n\n\n\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n    if isinstance(assertion_repetition,int):\n        number_of_repetitions = assertion_repetition\n    else:\n        number_of_repetitions = assertion_repetition.do_assert(architecture_file)    # Assertion is checked\n\n    xpath_in = ['/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/SRB', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/P80', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/GEM60']\n    xpath_out = ['/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Thrust', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/mdot']\n\n\n    # It is needed to know at what iteration the workflow is\n    index = RCE.read_state_variable (\"iteration\")\n    if index is None:\n        index = 1\n\n    index_iter = RCE.read_state_variable (\"index_iteration\")\n    if index_iter is None:\n        index_iter = 1\n\n    tool_activation_logic = XPathExists('/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/SRB') | XPathExists('/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/P80') | XPathExists('/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/GEM60')\n    activation_str = repr(tool_activation_logic)\n    flag = 0\n    while flag == 0:\n        if \"INDEX\" in activation_str:\n            tool_activation_logic = parse_expression(activation_str.replace(\"{INDEX}\", str(index)))\n        activation = tool_activation_logic.do_assert(architecture_file)\n        if activation == True:\n            flag = 1\n        else:\n            index = index + 1\n\n\n\n\n\n\n\n    xpaths_output = []\n    values_output = []\n    keys_output = []\n\n    # Inputs are iterated before outputs. Changes to the workflow xml are introduced here. These are the uid tags rename\n    for xpath in xpath_in:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            xpath_to_search_no_number = re.findall(r\".*{INDEX}.*?/\", xpath_no_root)[0][:-1]\n            xpath_check = xpath_to_search_no_number.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n\n\n            try:  # Might have been changed already before\n                root.find(xpath_check).attrib[key_repetition] = value_index\n            except:\n                pass\n\n    for xpath in xpath_out:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            value_repetition = value_index.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n            xpath_to_save_repetition = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0]\n            xpath_for_rest_of_attributes = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0] + re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[1]\n            if \"@\" in xpath_to_save_repetition:\n                attributes = re.findall(\"\\[@.*?]\", xpath_for_rest_of_attributes)\n                xpath_iteration = xpath_for_rest_of_attributes\n                for element in attributes:\n                    keys_output.append(re.search(\"@([^=]+)=\", element).group(1))\n                    values_output.append(re.search('@[^=]+=\"([^\"]+)\"', element).group(1))\n                    xpath_split = re.split(\"\\[@.*?]\", xpath_iteration, 1)\n                    xpaths_output.append(xpath_split[0])\n                    xpath_iteration = xpath_split[0] + xpath_split[1]\n\n\n            keys_output.append(key_repetition)\n            values_output.append(value_repetition)\n            xpaths_output.append(xpath_to_save_repetition)\n\n\n    input_file = RCE.create_input_file()\n    file = input_file.write_to_file(\"g_l\")\n\n    f = open(file, 'w')\n    f.write(str(xpaths_output) + \"\\n\")\n    f.write(str(keys_output) + \"\\n\")\n    f.write(str(values_output) + \"\\n\")\n    f.write (str(number_of_repetitions))\n    RCE.write_output(\"xpaths_uids\", file)\n    if index_iter == number_of_repetitions:\n        RCE.write_state_variable (\"iteration\", 1)\n        RCE.write_state_variable (\"index_iteration\", 1)\n    else:\n        RCE.write_state_variable (\"iteration\", index+1)\n        RCE.write_state_variable (\"index_iteration\", index_iter+1)\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = NumberofInstances('/Rocket/Stage/Engines', 'Solid')\ndeactivation_logic = None\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "8a6ca357-6bf6-4b10-b467-a125ea4cd573",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "330844a5-3b59-479e-8933-40b7fb23c753",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "f365bd9b-cfe6-418b-9636-d5be1cba1c9d",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "deecb646-480c-435f-8642-87ddd8ed44eb",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "2d9954f0-3463-4b85-b381-ed2d63fe1db7",
    "name" : "Sol_prop_input_filter",
    "location" : "905:670",
    "zIndex" : "11",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Solid\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Solid\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "4001d1d5-d601-4811-9935-5ebcd84618b5",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "c35933b4-4190-4a9d-9606-5019280e1c1b",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "bd65a606-7f39-498e-a615-af15b941143b",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "80eb3460-eb7e-4589-955d-43fe61b55919",
    "name" : "Sol_prop_iterator",
    "location" : "1370:740",
    "zIndex" : "17",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "import re\n\n\nindex = RCE.read_state_variable (\"iteration\")\nif index is None:\n    index = 1    # Iterations finished\n\n\nbase_path = RCE.read_input(\"XML\")\n\ntry:\n    file_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\n    with open(file_xpaths_uids, \"r\") as f:\n        lines = f.readlines()\n\n    repetitions = int(lines[3])\nexcept:    # This is a zero run loop in case of repetition plus activation\n    repetitions = 1\n\nRCE.write_output(\"XML\", base_path)\n\n\nif index == repetitions:\n    RCE.write_output(\"statement\", True)\n    RCE.write_state_variable (\"iteration\",1)\r\n    RCE.close_all_outputs()\nelse:\n    RCE.write_output(\"statement\", False)\n    RCE.write_state_variable (\"iteration\",index+1)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "85309854-d774-4a41-853b-f8b0a7b04264",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "c7547c7f-763c-462d-b9af-62daa650c192",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "NotRequired",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "f4a4ecce-dd30-4004-9ac5-ff52bdf8dfc2",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "ac6b74dd-d4d5-4232-a790-909b920872d6",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "a727b119-42ef-47a5-82db-ad08e3d52ee7",
    "name" : "Sol_prop_joiner_activation",
    "location" : "1295:760",
    "zIndex" : "16",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "e27aed6c-3a60-490b-9839-290a0f50b213",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "7c72341d-f5ef-4dde-a903-9a237723f048",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "b17425da-792e-4483-8b47-fb5ab8bcf943",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "a90e7aac-293a-450e-a2dd-baa9fe8f6dee",
    "name" : "Sol_prop_joiner_repetition",
    "location" : "1020:580",
    "zIndex" : "19",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "51fffb79-8f43-46fc-b87d-925ef3134d92",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "53c6a659-90b9-4dfe-a70f-5428e2fd9141",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "5fc8d2f5-a579-474e-a124-658e3710083a",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "64342252-731f-430b-addb-ced4eecbd652",
    "name" : "Sol_prop_local_to_global",
    "location" : "1070:740",
    "zIndex" : "21",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport os\nimport ast\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nbase_path = RCE.read_input(\"XML\")\n# Rename input file, otherwise RCE will not update input files in subsequent script executions\nbase_path_renamed = random_rename(base_path)\nos.rename(base_path, base_path_renamed)\n\n# XML and statement\ntree = et.parse(base_path_renamed)\nroot = tree.getroot()\n\n# We read the list of outputs and their uids.\n\nfile_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\nwith open(file_xpaths_uids, \"r\") as f:\n    lines = f.readlines()\n\nxpaths_output = ast.literal_eval(lines[0])\nkeys_output = ast.literal_eval(lines[1])\nvalues_output = ast.literal_eval(lines[2])\n\nfor i in range(len(xpaths_output)):\n     xpath = xpaths_output[i]\n     key = keys_output[i]\n     value = values_output[i]\n     root.find(xpath).set(key, value)\n\n\n# Output xml\noutput_path = random_rename(base_path, same_path=False)\nf_base = open(output_path, \"wb\")\ntree.write(f_base, encoding=\"utf-8\")\nf_base.close()\nRCE.write_output(\"XML\", output_path)\n\ndef random_rename(file_path, same_path=True):\n    file_name, file_ext = os.path.splitext(file_path)\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "2a97fdc8-1846-4812-a08c-37bb8abdb52a",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "242de0f0-2297-4285-bfde-7107aaf84ca9",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "9dae96c0-4b91-4e48-acb4-417dd0a16611",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "0b1bccf5-873b-43a4-b8c0-6b6f01f9010a",
    "name" : "Sol_prop_merge_script",
    "location" : "1185:740",
    "zIndex" : "13",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "4d40e1b4-e3a5-4a52-8bc4-737f96cc85cf",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "5f3f7b3e-e3c9-42bb-9a5a-970b57b7488b",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "906f9c42-a087-417a-bdd7-3a2c7ed7171e",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "56075b58-78e0-4e7e-876d-a1b9d2a1eee9",
    "name" : "Sol_prop_output_filter",
    "location" : "995:760",
    "zIndex" : "12",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "210d9cfe-f149-4641-a679-aca816b05fc2",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "0e423e61-5620-423b-b870-bec64c482816",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "4685394d-01cb-409e-902b-75beed95322e",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "6f651592-d25d-41c5-ae3d-137e205bfc1f",
    "name" : "Sol_prop_repetition_switch",
    "location" : "1480:760",
    "zIndex" : "18",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "f616b51f-8563-4222-bda5-a3196b41b83c",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "db1508de-9316-4d54-b225-03ac7aeea5d0",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "63e18bac-2799-4757-8dd7-6bde11ed563e",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "1b0c2b34-f2e8-4e2a-97b8-2cd641c5715a",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "672c5daf-90d8-4f04-836c-243fb8615d31",
    "name" : "Sol_prop_switch_activation",
    "location" : "1020:510",
    "zIndex" : "14",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "43b17cb3-fc22-4c29-be06-8ecff1e66235",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "6991766b-166f-40fa-b8bd-5f83b2f41366",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "d6c9744e-9fe7-4241-8caa-b92ba0626ef6",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "abf942bf-2e26-4d27-a050-1eb84063cf45",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "a3f8e5a7-ef7a-4f44-a7aa-a00b3da68a1b",
    "name" : "Space_cost",
    "location" : "3385:2140",
    "zIndex" : "68",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Space_cost",
      "version" : "1.0",
      "name" : "Space_cost"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "dd972c76-aa15-4b2f-9473-20a5177e8742",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "d44ca2b0-0f72-492a-a701-1312264f7936",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "bb910e8e-87aa-4e57-b8aa-a6a1a10f1039",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "b99209a6-4e51-4de1-8fe9-a532501a7d0f",
    "name" : "Space_geometry",
    "location" : "1535:1170",
    "zIndex" : "64",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Space_geometry",
      "version" : "1.0",
      "name" : "Space_geometry"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "a1330011-26f5-44fc-8f33-763ca53aa11d",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "8be45d40-808b-4b49-bc8e-53849a385528",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "5a3563ad-cc9d-4aaa-afff-567c7278da6c",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "2ab3ef2f-0ee4-46d0-8c06-62388ae2182f",
    "name" : "Space_payload",
    "location" : "4176:2500",
    "zIndex" : "70",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Space_payload",
      "version" : "1.0",
      "name" : "Space_payload"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "2d3e54f1-5280-4e6c-9c7f-fcdb031024cf",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "1d25f59e-f844-4e51-a6b8-c6037b0ae9ba",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "31e3d96e-a2ea-4ae7-ba49-89090cc9de7d",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "766ae56a-60a8-443c-9680-0adf95d290cb",
    "name" : "Space_propellant",
    "location" : "1935:1350",
    "zIndex" : "65",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Space_propellant",
      "version" : "1.0",
      "name" : "Space_propellant"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "c1f7b00d-eeef-45c7-ba97-9e18091a93ce",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "9ec978df-54e3-4ab2-a5ba-67fb3354b795",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "967d849f-c71f-46ea-96cb-d0404a39198a",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "c480e964-c643-493f-acfa-d3e4779c5f49",
    "name" : "Space_str_constraint",
    "location" : "3779:2320",
    "zIndex" : "69",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Space_str_constraint",
      "version" : "1.0",
      "name" : "Space_str_constraint"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "7d95fbad-a38e-4ac2-8c48-44e27395d788",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "eda45f79-3868-493e-9db3-3ad853713c2d",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "7ba81ea1-9a02-45ae-9527-b6b8b5f4591f",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "77796dfa-b35b-497f-b8d6-eb642329d48f",
    "name" : "Space_structures",
    "location" : "2460:1655",
    "zIndex" : "66",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Space_structures",
      "version" : "1.0",
      "name" : "Space_structures"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "7fadff44-704c-4415-9bb4-f1d3932fb0ad",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "73d3fa59-27fa-4b4f-8a8d-28fa8d63ee16",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "b445babc-6d84-4464-9a73-e6a21ee67c15",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "ed464c15-cda5-453c-8f31-cf2770a286bc",
    "name" : "Space_trajectory",
    "location" : "2985:1960",
    "zIndex" : "67",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Space_trajectory",
      "version" : "1.0",
      "name" : "Space_trajectory"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "80e59eff-bd7b-4c9f-9b19-d42939e00996",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "a0c5a885-4c20-4a02-94a9-4091b690d1a3",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "5a9f1ba8-ff31-4b40-a545-1e50bb959a63",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "3ff58738-0b8b-42a8-9ddc-664f1a14cb13",
    "name" : "Struct_const_input_filter",
    "location" : "3805:2250",
    "zIndex" : "53",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Structure/Max_q |\n\t\t\t/Rocket/Trajectory\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Structure/Max_q |\n\t\t\t/Rocket/Trajectory\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "e3be3fc9-5262-4d84-91a4-16efb6309038",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "01d5b15c-0294-4064-a41b-91dfe379cc04",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "77ee67de-0918-4f65-b9ee-99f152d845a7",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "3549b0c7-cf06-4dbd-8b35-f8600cb8406f",
    "name" : "Struct_const_merge_script",
    "location" : "3970:2320",
    "zIndex" : "55",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "125e0973-ba8c-4b7b-9a8e-55c0fb45c4b5",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "ebd2287f-099a-43cf-96d0-1c57de774f5a",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "01524cc9-9456-49f5-a155-61e279374040",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "f56502f3-a4da-40fe-a87c-169f12e8ac5a",
    "name" : "Struct_const_output_filter",
    "location" : "3895:2340",
    "zIndex" : "54",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Structure/Constraint\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Structure/Constraint\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "070e4cd0-c6da-485a-8065-3fe0e2738fa3",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "d6276186-4a2e-475e-a2bb-d478f8f8338e",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "af6dee9d-96ce-4dd3-bcd1-354f5d1cc66c",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "e7c9a145-c3e0-44a8-8af8-c8ff6ab838af",
    "name" : "Struct_const_splitter",
    "location" : "3875:2250",
    "zIndex" : "56",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlvalues",
      "version" : "1.0",
      "name" : "XML Values"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "8b9e4b30-da26-48f4-8bce-181feaf84b95",
      "name" : "XML",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "405787ef-ec70-4968-b5f2-5c4cfbb71781",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "85691c05-1432-48f8-81c3-f80c64e40756",
    "name" : "Struct_mass_concurrency_resolution_3755da9A",
    "location" : "2575:740",
    "zIndex" : "42",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "7abd4994-0a2f-493d-99de-a1f950b9f5a0",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "043951ba-acdc-4227-a16c-a6438d51d28f",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "72931c17-fbef-4cf5-a204-69737cd85b76",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "b122b25e-3bf3-4750-9444-34f26237a925",
    "name" : "Struct_mass_concurrency_resolution_3d5eCb1E",
    "location" : "2575:1350",
    "zIndex" : "43",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "087f99a9-62ce-4e87-ab28-15ae814c27b2",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "c5c10821-b9fa-4874-bff1-b07d7b01cf2b",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "e965a379-537d-4e41-b9ca-46fc3efe6ab4",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "5abe9c36-987a-4f65-8738-206c584b7698",
    "name" : "Struct_mass_concurrency_resolution_3d5eCb1E_merger",
    "location" : "2595:1280",
    "zIndex" : "44",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage/Engines/Expansion_ratio |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage/Engines/Expansion_ratio |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "5f99550c-d85c-4438-952c-98e06df3dbcb",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "fd6335f0-57a2-4def-9af3-d74dc8e4e9cf",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "a8875116-c2e3-4481-b033-2d710e36be89",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "60750a4a-72df-4636-bc5b-f0526242fc3c",
    "name" : "Struct_mass_global_to_local",
    "location" : "2575:1565",
    "zIndex" : "40",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n   # Might be all or just some depending on the case scenario\nclass NumberofInstances(XPathAssertion):\n\n    \"\"\"Determines the number of child nodes with a certain tag\"\"\"\n\n\n\n    def __init__(self, xpath, instance):\n\n        super(NumberofInstances, self).__init__(xpath)\n\n        self._instance = instance\n\n\n\n    def _assert(self, els):\n\n        instance = self._instance\n\n        counter = 0\n\n        for element in els:\n\n            counter = counter + len(element.findall(instance))\n\n        return counter\n\n\n\n    def __repr__(self):\n\n        return \"{class_name}('{xpath}', '{instance}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, instance=self._instance)\n\n\n\n\n\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n    if isinstance(assertion_repetition,int):\n        number_of_repetitions = assertion_repetition\n    else:\n        number_of_repetitions = assertion_repetition.do_assert(architecture_file)    # Assertion is checked\n\n    xpath_in = ['/Rocket/Geometry/Diameter', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Oxidizer_tank_volume', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/SIVB', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Thrust', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Propellant', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Head_surface', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Oxidizer_tank_surface', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Length', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Expansion_ratio', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/VULCAIN', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Fuel_tank_surface', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid/RS68', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/SRB', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Geometry/Fuel_tank_volume', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/P80', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Solid/GEM60']\n    xpath_out = ['/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Pumps', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Insulation', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Tanks', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Casing', '/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Mass/Structure']\n\n\n    # It is needed to know at what iteration the workflow is\n    index = RCE.read_state_variable (\"iteration\")\n    if index is None:\n        index = 1\n\n    index_iter = RCE.read_state_variable (\"index_iteration\")\n    if index_iter is None:\n        index_iter = 1\n\n\n\n    xpaths_output = []\n    values_output = []\n    keys_output = []\n\n    # Inputs are iterated before outputs. Changes to the workflow xml are introduced here. These are the uid tags rename\n    for xpath in xpath_in:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            xpath_to_search_no_number = re.findall(r\".*{INDEX}.*?/\", xpath_no_root)[0][:-1]\n            xpath_check = xpath_to_search_no_number.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n\n\n            try:  # Might have been changed already before\n                root.find(xpath_check).attrib[key_repetition] = value_index\n            except:\n                pass\n\n    for xpath in xpath_out:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            value_repetition = value_index.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n            xpath_to_save_repetition = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0]\n            xpath_for_rest_of_attributes = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0] + re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[1]\n            if \"@\" in xpath_to_save_repetition:\n                attributes = re.findall(\"\\[@.*?]\", xpath_for_rest_of_attributes)\n                xpath_iteration = xpath_for_rest_of_attributes\n                for element in attributes:\n                    keys_output.append(re.search(\"@([^=]+)=\", element).group(1))\n                    values_output.append(re.search('@[^=]+=\"([^\"]+)\"', element).group(1))\n                    xpath_split = re.split(\"\\[@.*?]\", xpath_iteration, 1)\n                    xpaths_output.append(xpath_split[0])\n                    xpath_iteration = xpath_split[0] + xpath_split[1]\n\n\n            keys_output.append(key_repetition)\n            values_output.append(value_repetition)\n            xpaths_output.append(xpath_to_save_repetition)\n\n\n    input_file = RCE.create_input_file()\n    file = input_file.write_to_file(\"g_l\")\n\n    f = open(file, 'w')\n    f.write(str(xpaths_output) + \"\\n\")\n    f.write(str(keys_output) + \"\\n\")\n    f.write(str(values_output) + \"\\n\")\n    f.write (str(number_of_repetitions))\n    RCE.write_output(\"xpaths_uids\", file)\n    if index_iter == number_of_repetitions:\n        RCE.write_state_variable (\"iteration\", 1)\n        RCE.write_state_variable (\"index_iteration\", 1)\n    else:\n        RCE.write_state_variable (\"iteration\", index+1)\n        RCE.write_state_variable (\"index_iteration\", index_iter+1)\n\n    dictionary = deactivation_logic\n    root_removal = False    # In case a direct child of the root is deleted, it is needed to reformat the last line of the xml\n    for i_con in range(len(dictionary['Xpath'])):\n        xpath = dictionary['Xpath'][i_con]\n        architectural_decision = dictionary['Architectural_decision'][i_con]\n        if architectural_decision.do_assert(architecture_file):    # It means the variable has to be disactivated\n            xpath_no_root = xpath.split('/', 2)[2]\n            try:    # Delete process is different depending if the delete takes place in a direct child of the root or not\n                parent = xpath_no_root.rsplit(\"/\", 1)[0]\n                child = xpath_no_root.rsplit(\"/\", 1)[1]\n                for possible_parent in root.findall(parent):\n                    children = possible_parent.findall(child)\n                    for possible_child in children:\n                        possible_parent.remove(possible_child)\n                    possible_parent.text = possible_parent.text[:-1]\n            except:\n                parent = xpath_no_root\n                for possible_parent in root.findall(parent):\n                    root.remove(possible_parent)\n                root_removal = True\n\n\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = NumberofInstances('/Rocket', 'Stage')\ndeactivation_logic = {'Xpath': ['/Rocket/Stage/Mass'], 'Architectural_decision': [XPathExists('/Rocket/Stage[@UID=\"stage_{INDEX}\"]/Engines/Liquid')]}\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "f90e6f29-6ef1-4614-a19f-591f00bd0764",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "48328e7d-2dcb-4de4-8b61-e059bd7b90de",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "57c15506-3854-43e2-8a52-b4936955890e",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "16773b73-da5a-4b5f-88ab-b8841c2f3aef",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "ad15c2a5-1245-4571-98f9-15debef9afd2",
    "name" : "Struct_mass_input_filter",
    "location" : "2480:1585",
    "zIndex" : "34",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Geometry/Diameter |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Expansion_ratio |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Liquid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Solid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Thrust |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Fuel_tank_surface |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Fuel_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Head_surface |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Length |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Oxidizer_tank_surface |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Oxidizer_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Mass/Propellant\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Geometry/Diameter |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Expansion_ratio |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Liquid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Solid |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Engines/Thrust |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Fuel_tank_surface |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Fuel_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Head_surface |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Length |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Oxidizer_tank_surface |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Geometry/Oxidizer_tank_volume |\n\t\t\t/Rocket/Stage[@UID='stage_{INDEX}']/Mass/Propellant\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "9ea178f9-db8f-406b-926b-cedc281db550",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "5df4980d-2531-4151-abdc-12665ca3b891",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "e0f2ec87-0127-4675-9619-735eefe1a534",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "b657c21f-ac8e-4f19-803c-38e1638276dd",
    "name" : "Struct_mass_iterator",
    "location" : "2875:1655",
    "zIndex" : "37",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "import re\n\n\nindex = RCE.read_state_variable (\"iteration\")\nif index is None:\n    index = 1    # Iterations finished\n\n\nbase_path = RCE.read_input(\"XML\")\n\ntry:\n    file_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\n    with open(file_xpaths_uids, \"r\") as f:\n        lines = f.readlines()\n\n    repetitions = int(lines[3])\nexcept:    # This is a zero run loop in case of repetition plus activation\n    repetitions = 1\n\nRCE.write_output(\"XML\", base_path)\n\n\nif index == repetitions:\n    RCE.write_output(\"statement\", True)\n    RCE.write_state_variable (\"iteration\",1)\r\n    RCE.close_all_outputs()\nelse:\n    RCE.write_output(\"statement\", False)\n    RCE.write_state_variable (\"iteration\",index+1)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "b249e06b-770c-4b00-a5e8-b04939613ec6",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "0877d9f4-88d8-461e-9462-3c1754779323",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "NotRequired",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "db8b7c2d-4401-4ba7-bd18-61a3c33cae83",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "202c5402-aeed-46c6-bccd-d28db0c80251",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "7387d770-dec2-4b73-b37f-f27708ff3f72",
    "name" : "Struct_mass_joiner_repetition",
    "location" : "2595:1495",
    "zIndex" : "39",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "e94a7906-82e0-4128-b839-3a0423b4dbbe",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "c0a186e8-f4d2-4142-90f0-2106ca389f7d",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "97a16bd4-5b94-4c2a-8756-cf0702222c56",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "dac5e7c6-0480-43f9-bb14-f32e162c85ca",
    "name" : "Struct_mass_local_to_global",
    "location" : "2645:1655",
    "zIndex" : "41",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport os\nimport ast\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nbase_path = RCE.read_input(\"XML\")\n# Rename input file, otherwise RCE will not update input files in subsequent script executions\nbase_path_renamed = random_rename(base_path)\nos.rename(base_path, base_path_renamed)\n\n# XML and statement\ntree = et.parse(base_path_renamed)\nroot = tree.getroot()\n\n# We read the list of outputs and their uids.\n\nfile_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\nwith open(file_xpaths_uids, \"r\") as f:\n    lines = f.readlines()\n\nxpaths_output = ast.literal_eval(lines[0])\nkeys_output = ast.literal_eval(lines[1])\nvalues_output = ast.literal_eval(lines[2])\n\nfor i in range(len(xpaths_output)):\n     xpath = xpaths_output[i]\n     key = keys_output[i]\n     value = values_output[i]\n     root.find(xpath).set(key, value)\n\n\n# Output xml\noutput_path = random_rename(base_path, same_path=False)\nf_base = open(output_path, \"wb\")\ntree.write(f_base, encoding=\"utf-8\")\nf_base.close()\nRCE.write_output(\"XML\", output_path)\n\ndef random_rename(file_path, same_path=True):\n    file_name, file_ext = os.path.splitext(file_path)\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "903e6060-3347-48f8-8fae-affb7b6ca911",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "5248703b-b5a6-4b94-9edb-a87061dae9f5",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "9d1f2f3e-63d3-4c74-84db-d2dbc0b5efba",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "57d98f8a-e0cb-4545-9e48-c5e49fea73f3",
    "name" : "Struct_mass_merge_script",
    "location" : "2760:1655",
    "zIndex" : "36",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "55aeebf8-536b-46e9-8029-c95406dc0120",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "98c3b649-56e7-4d94-8d82-96f6efae542c",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "cd33c091-a6a1-4a1d-98f7-7c0b5d5cf347",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "a6b2d463-809b-4a5e-b172-f6217bee22f2",
    "name" : "Struct_mass_output_filter",
    "location" : "2570:1675",
    "zIndex" : "35",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Stage/Mass/Casing |\n\t\t\t/Rocket/Stage/Mass/Insulation |\n\t\t\t/Rocket/Stage/Mass/Pumps |\n\t\t\t/Rocket/Stage/Mass/Structure |\n\t\t\t/Rocket/Stage/Mass/Tanks\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Stage/Mass/Casing |\n\t\t\t/Rocket/Stage/Mass/Insulation |\n\t\t\t/Rocket/Stage/Mass/Pumps |\n\t\t\t/Rocket/Stage/Mass/Structure |\n\t\t\t/Rocket/Stage/Mass/Tanks\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "91dce61a-f43c-4930-aa1f-fa9656dff254",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "a73ad48a-38b4-4b2c-9d69-a36464516c45",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "eb867a97-189e-40b5-a4f5-f02f5a04d2e0",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "de79d00a-6f75-4a65-97fa-62cd4b55ecf4",
    "name" : "Struct_mass_repetition_switch",
    "location" : "2985:1675",
    "zIndex" : "38",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "ba27aaf9-9673-4625-a74d-c4b0f234bcf9",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "15910c0a-816a-4795-a9d2-2c885d21a80c",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "2793ab95-fe7b-4a3a-985b-7e4c56754632",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "4a6357cb-89bd-49bd-8e1e-c0dc1454e05d",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "cf2a2b81-640c-4947-9023-57bfb8114e16",
    "name" : "Trajectory_input_filter",
    "location" : "3005:1890",
    "zIndex" : "45",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Geometry/Cone_angle |\n\t\t\t/Rocket/Geometry/Diameter |\n\t\t\t/Rocket/Geometry/Head_shape |\n\t\t\t/Rocket/Geometry/L_ratio_ellipse |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot |\n\t\t\t/Rocket/Stage/Mass\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Geometry/Cone_angle |\n\t\t\t/Rocket/Geometry/Diameter |\n\t\t\t/Rocket/Geometry/Head_shape |\n\t\t\t/Rocket/Geometry/L_ratio_ellipse |\n\t\t\t/Rocket/Stage/Engines/Thrust |\n\t\t\t/Rocket/Stage/Engines/mdot |\n\t\t\t/Rocket/Stage/Mass\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "9123d960-f595-4226-9cb3-45c1bf551c6b",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "002c8178-496d-495d-bdcb-58073edab907",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "1a0508de-5b90-4234-b9c8-a2badbd7ed46",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "db67f7f9-265f-441a-9ee5-1f90c25609b5",
    "name" : "Trajectory_merge_script",
    "location" : "3170:1960",
    "zIndex" : "47",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "2f77488b-79d4-40c8-a0a3-0db00508afc7",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "bc9d02ab-c8fe-41fa-a3b3-99c1036947bb",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "9ce53082-cbc4-4c8a-a542-93286be28feb",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "205c9e1b-a0a3-4d72-8c4a-3b5d72c1d84c",
    "name" : "Trajectory_output_filter",
    "location" : "3095:1980",
    "zIndex" : "46",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/Rocket/Payload/Mass |\n\t\t\t/Rocket/Trajectory\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/Rocket/Payload/Mass |\n\t\t\t/Rocket/Trajectory\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "0f58e97c-a004-4495-8142-f4989589f5dc",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "30595569-3200-4f4b-8a64-b1bbc46e41ee",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "cb4a530b-99f8-4b9e-9241-950cfcbfde72",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "64f1afa2-163c-4d0c-994a-4c7f6913ae3d",
    "name" : "Trajectory_splitter",
    "location" : "3075:1890",
    "zIndex" : "48",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlvalues",
      "version" : "1.0",
      "name" : "XML Values"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "7f7bdffc-beac-4d34-a150-5aa91ed520e5",
      "name" : "XML",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "5e02af59-e42f-4386-97ab-269c299fcb6f",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  } ],
  "connections" : [ {
    "source" : "1cdae4e7-38e3-4280-9af1-08d83e0bc98d",
    "output" : "7e5fad76-db22-4785-af69-2630e8551fce",
    "target" : "a3f8e5a7-ef7a-4f44-a7aa-a00b3da68a1b",
    "input" : "dd972c76-aa15-4b2f-9473-20a5177e8742"
  }, {
    "source" : "b6a60a36-cdf6-46a4-8fee-d99e2a7a8e69",
    "output" : "2b1e45f7-4082-40e2-ae7a-c1ec8bdcfe75",
    "target" : "9618781c-edc6-4642-b560-5d05a82f8ab2",
    "input" : "1d3b9346-c6f5-4553-a841-60a5a65ec623"
  }, {
    "source" : "686d0676-b5a2-4d2f-965d-70430c05c0ae",
    "output" : "e26b42a8-c227-45b3-9e9b-6fc9b375c309",
    "target" : "b6a60a36-cdf6-46a4-8fee-d99e2a7a8e69",
    "input" : "09ce04ea-cf32-45e5-96be-8e63a33fad1e"
  }, {
    "source" : "853f4bc7-9755-436f-8bcc-49a54b73b2e8",
    "output" : "dcb63aad-db87-4dca-86fc-84317628700a",
    "target" : "1cdae4e7-38e3-4280-9af1-08d83e0bc98d",
    "input" : "4c8ee6c3-efde-4318-9144-76ba260f9b58"
  }, {
    "source" : "853f4bc7-9755-436f-8bcc-49a54b73b2e8",
    "output" : "dcb63aad-db87-4dca-86fc-84317628700a",
    "target" : "1cdae4e7-38e3-4280-9af1-08d83e0bc98d",
    "input" : "552b2525-108b-41d2-9dc2-174e420dddc7"
  }, {
    "source" : "853f4bc7-9755-436f-8bcc-49a54b73b2e8",
    "output" : "dcb63aad-db87-4dca-86fc-84317628700a",
    "target" : "b6a60a36-cdf6-46a4-8fee-d99e2a7a8e69",
    "input" : "0b4cacf4-f4e6-43ae-8557-32eaaa5a8a7a"
  }, {
    "source" : "29db3508-b008-41be-9e4b-573cdd7a0b86",
    "output" : "9fd00567-d257-438b-98ad-0d73727dd17c",
    "target" : "56075b58-78e0-4e7e-876d-a1b9d2a1eee9",
    "input" : "210d9cfe-f149-4641-a679-aca816b05fc2"
  }, {
    "source" : "29db3508-b008-41be-9e4b-573cdd7a0b86",
    "output" : "9fd00567-d257-438b-98ad-0d73727dd17c",
    "target" : "56075b58-78e0-4e7e-876d-a1b9d2a1eee9",
    "input" : "0e423e61-5620-423b-b870-bec64c482816"
  }, {
    "source" : "96175205-e108-45cc-aa13-5d3b60e0fab1",
    "output" : "65588f44-f3fd-44c6-8360-9274638e8e77",
    "target" : "b99209a6-4e51-4de1-8fe9-a532501a7d0f",
    "input" : "a1330011-26f5-44fc-8f33-763ca53aa11d"
  }, {
    "source" : "9ce122ac-53d5-4da7-8253-953f880883ee",
    "output" : "a75ad1a3-f0f4-45de-812a-bc9acabbe00c",
    "target" : "d0b5d7c3-158f-4abd-a900-598e93943d17",
    "input" : "c45ac4ac-4ea8-428a-8727-5bd99a164c9b"
  }, {
    "source" : "9a147e3b-2160-418a-9edb-1d5dda7e137f",
    "output" : "3f01866d-c8a0-4076-9851-bd9249c5d80b",
    "target" : "9ce122ac-53d5-4da7-8253-953f880883ee",
    "input" : "eec14963-bce3-4eb0-a094-56ab98e0a969"
  }, {
    "source" : "dbe88bec-d81c-4a27-8448-42f1900b5dd6",
    "output" : "b0d86ef1-a41c-43db-a3ea-2506719d5c85",
    "target" : "96175205-e108-45cc-aa13-5d3b60e0fab1",
    "input" : "5fd00b10-4283-4b62-a8a4-016a00909b33"
  }, {
    "source" : "dbe88bec-d81c-4a27-8448-42f1900b5dd6",
    "output" : "b0d86ef1-a41c-43db-a3ea-2506719d5c85",
    "target" : "96175205-e108-45cc-aa13-5d3b60e0fab1",
    "input" : "ce848114-0c77-41d8-a09a-3017885794e5"
  }, {
    "source" : "dbe88bec-d81c-4a27-8448-42f1900b5dd6",
    "output" : "b0d86ef1-a41c-43db-a3ea-2506719d5c85",
    "target" : "9ce122ac-53d5-4da7-8253-953f880883ee",
    "input" : "cb59480f-a9e4-4a3b-bdfc-a1f5fd89b889"
  }, {
    "source" : "c1cfc5a0-a5e1-447e-985f-d8ee2192ad6d",
    "output" : "d4c0c5c6-f74b-48c3-b4b4-445cb7fdd2ab",
    "target" : "dbe88bec-d81c-4a27-8448-42f1900b5dd6",
    "input" : "2f8d6fc9-4c5c-47ba-81d9-9439d751e4ff"
  }, {
    "source" : "c1cfc5a0-a5e1-447e-985f-d8ee2192ad6d",
    "output" : "d4c0c5c6-f74b-48c3-b4b4-445cb7fdd2ab",
    "target" : "7d0bc860-c353-46da-980b-26ffb474d50f",
    "input" : "48a611bf-53de-4a00-bdbd-381988303ef3"
  }, {
    "source" : "c1cfc5a0-a5e1-447e-985f-d8ee2192ad6d",
    "output" : "d4c0c5c6-f74b-48c3-b4b4-445cb7fdd2ab",
    "target" : "55974baf-3717-428b-ab7b-e0ddb3c75a05",
    "input" : "4aad0149-fb6c-470a-bdca-60ae198bbd30"
  }, {
    "source" : "7d0bc860-c353-46da-980b-26ffb474d50f",
    "output" : "cb6dc3e3-de01-4531-a9c3-e5f888e72b9f",
    "target" : "b46467c3-7e3a-4755-898f-9f2e8bcd30ce",
    "input" : "74afcd5b-09f4-447e-b4bd-2ce553bce4ac"
  }, {
    "source" : "7d0bc860-c353-46da-980b-26ffb474d50f",
    "output" : "3214a7a2-118f-499e-9192-f8a73056b72b",
    "target" : "b46467c3-7e3a-4755-898f-9f2e8bcd30ce",
    "input" : "bee82a36-a0dc-48e9-b4c6-94344a95311a"
  }, {
    "source" : "e3076cb2-12d3-4c1c-9125-be8a29b7dba2",
    "output" : "50bbdec3-fc53-47d2-96cb-754f033ba0bb",
    "target" : "3473d476-500d-42d8-bf66-c57b34b20f9b",
    "input" : "4ea3725b-fa9d-4f32-92e4-2af0186898a9"
  }, {
    "source" : "e3076cb2-12d3-4c1c-9125-be8a29b7dba2",
    "output" : "50bbdec3-fc53-47d2-96cb-754f033ba0bb",
    "target" : "3473d476-500d-42d8-bf66-c57b34b20f9b",
    "input" : "7730ba2f-ef4d-490c-a2c4-fa6d2e1e75a7"
  }, {
    "source" : "e3076cb2-12d3-4c1c-9125-be8a29b7dba2",
    "output" : "f16d562f-37ed-4069-95d9-c6d1bd3a8a87",
    "target" : "c92c9604-10d6-4977-8354-eae9d089845e",
    "input" : "4f9d0d6c-bdd6-48a6-8619-e388ed037980"
  }, {
    "source" : "e3076cb2-12d3-4c1c-9125-be8a29b7dba2",
    "output" : "4a2c578a-dcdf-4bab-a6b1-dae791159ab6",
    "target" : "1041e708-0e55-474f-9b1c-8a9f6321a884",
    "input" : "e2481978-1a9b-4649-a108-baf69e6dd206"
  }, {
    "source" : "e3076cb2-12d3-4c1c-9125-be8a29b7dba2",
    "output" : "4a2c578a-dcdf-4bab-a6b1-dae791159ab6",
    "target" : "29d1c39c-85b5-4a95-b7a5-d8d9cc455eea",
    "input" : "8af7db8e-2ed6-42ee-b2cc-7c4d134804df"
  }, {
    "source" : "3473d476-500d-42d8-bf66-c57b34b20f9b",
    "output" : "99318140-d992-474e-9a5b-4819d04eac87",
    "target" : "c76e947d-ff6f-4e0d-ac87-afd1276c4b1a",
    "input" : "452f414e-bb18-40eb-8f81-3252e52e4e78"
  }, {
    "source" : "1041e708-0e55-474f-9b1c-8a9f6321a884",
    "output" : "f5c77d24-973d-4579-b3ba-1f8ca2b1628d",
    "target" : "65a76d99-e481-4589-807b-cfea451d5988",
    "input" : "e38d3bdc-c99b-4eda-b8f1-40ff091ec844"
  }, {
    "source" : "1041e708-0e55-474f-9b1c-8a9f6321a884",
    "output" : "0061c544-a7e9-41d7-a79e-6c95a0bfad7f",
    "target" : "65a76d99-e481-4589-807b-cfea451d5988",
    "input" : "2d58ba5d-b9b5-454f-b765-5ab26ca4963d"
  }, {
    "source" : "30eab269-13f4-418f-b14e-a2a11e29c40c",
    "output" : "da9bc352-81ad-4045-ba07-ea680f7060a6",
    "target" : "1041e708-0e55-474f-9b1c-8a9f6321a884",
    "input" : "d64a8fa7-0f48-4619-a828-9750452d4fdf"
  }, {
    "source" : "50f7364c-cb60-4c22-a158-70b5faf606ef",
    "output" : "108f8cc5-8572-4133-ad26-cb97ec5ffe6f",
    "target" : "e3076cb2-12d3-4c1c-9125-be8a29b7dba2",
    "input" : "42c41f14-a8c4-4940-a71c-cdd7f45a8897"
  }, {
    "source" : "29d1c39c-85b5-4a95-b7a5-d8d9cc455eea",
    "output" : "e0b5b8d9-728d-48d2-b9aa-f223d262c37f",
    "target" : "c92c9604-10d6-4977-8354-eae9d089845e",
    "input" : "a42daa3f-75e8-47b1-9681-6e063e78c727"
  }, {
    "source" : "c92c9604-10d6-4977-8354-eae9d089845e",
    "output" : "7cf93e22-3c1c-4ff1-972b-2807f55c4f7c",
    "target" : "30eab269-13f4-418f-b14e-a2a11e29c40c",
    "input" : "01a31dec-11cb-44e8-aebe-30e87cc4c8c9"
  }, {
    "source" : "a9f4d5bd-18ae-48c3-8ddc-7b8b352b002f",
    "output" : "a44d931b-994c-4eab-87f7-52bc4c553060",
    "target" : "29d1c39c-85b5-4a95-b7a5-d8d9cc455eea",
    "input" : "af7de67f-13f7-497f-a768-799c9ad59629"
  }, {
    "source" : "65a76d99-e481-4589-807b-cfea451d5988",
    "output" : "86785fbb-d099-41ee-933c-b3a8420e1491",
    "target" : "85691c05-1432-48f8-81c3-f80c64e40756",
    "input" : "043951ba-acdc-4227-a16c-a6438d51d28f"
  }, {
    "source" : "65a76d99-e481-4589-807b-cfea451d5988",
    "output" : "34f171b3-cd46-4120-be79-57ad51f039eb",
    "target" : "50f7364c-cb60-4c22-a158-70b5faf606ef",
    "input" : "b7e9346a-714f-4c1b-8ea9-6388d9571340"
  }, {
    "source" : "b46467c3-7e3a-4755-898f-9f2e8bcd30ce",
    "output" : "976c6325-613e-4850-90ad-c26486f4fac2",
    "target" : "50f7364c-cb60-4c22-a158-70b5faf606ef",
    "input" : "3fcedc7a-8a5c-41c2-bbfe-e7763193be83"
  }, {
    "source" : "b46467c3-7e3a-4755-898f-9f2e8bcd30ce",
    "output" : "56bb506e-8dd2-4158-8a9a-f77e5587d8c9",
    "target" : "30eab269-13f4-418f-b14e-a2a11e29c40c",
    "input" : "42cbe51c-99dd-4d00-95d3-9ccdbcc7d173"
  }, {
    "source" : "c76e947d-ff6f-4e0d-ac87-afd1276c4b1a",
    "output" : "fe5e2ed0-de22-4baf-bd09-b19e2745dfb3",
    "target" : "a9f4d5bd-18ae-48c3-8ddc-7b8b352b002f",
    "input" : "305a4ea7-7aa5-4da8-a021-fbba7b9b39bf"
  }, {
    "source" : "c76e947d-ff6f-4e0d-ac87-afd1276c4b1a",
    "output" : "fe5e2ed0-de22-4baf-bd09-b19e2745dfb3",
    "target" : "a9f4d5bd-18ae-48c3-8ddc-7b8b352b002f",
    "input" : "d02a3995-91ea-487e-96d0-7aebdc727a37"
  }, {
    "source" : "9618781c-edc6-4642-b560-5d05a82f8ab2",
    "output" : "bacd15b7-18c1-4802-a92c-397d6d4db59b",
    "target" : "baa70859-781d-4281-9177-450bc5a0d891",
    "input" : "09ad99b7-f864-4a80-9a81-e7e13950267c"
  }, {
    "source" : "2661aee0-700d-4dbb-825a-1f84ff27be47",
    "output" : "f616c728-b953-43f8-8922-a4ba3a947814",
    "target" : "2ab3ef2f-0ee4-46d0-8c06-62388ae2182f",
    "input" : "2d3e54f1-5280-4e6c-9c7f-fcdb031024cf"
  }, {
    "source" : "470b1407-d49a-4abc-b5cd-175792a6cf1a",
    "output" : "c134740b-ebdb-4abd-8815-ae4339f2785b",
    "target" : "9618781c-edc6-4642-b560-5d05a82f8ab2",
    "input" : "5fbc4438-b1e3-46b5-bba7-3bb3da415329"
  }, {
    "source" : "ad442ee6-86e8-413e-8919-953c5c196a42",
    "output" : "4da09d3a-20e9-419f-a279-d5a9ba412a32",
    "target" : "470b1407-d49a-4abc-b5cd-175792a6cf1a",
    "input" : "41ba5dbe-7b5b-4c1e-b028-ee742fd12acf"
  }, {
    "source" : "cb9573d4-d7c6-4dbf-85b6-edfb7c5f6742",
    "output" : "bae03932-3849-42b1-8ad8-beda248000a2",
    "target" : "2661aee0-700d-4dbb-825a-1f84ff27be47",
    "input" : "e2d81ff7-c049-40e1-9c1e-165b88c02dbc"
  }, {
    "source" : "cb9573d4-d7c6-4dbf-85b6-edfb7c5f6742",
    "output" : "bae03932-3849-42b1-8ad8-beda248000a2",
    "target" : "2661aee0-700d-4dbb-825a-1f84ff27be47",
    "input" : "fed07c1f-3bd0-42c9-899f-fd55e82e5479"
  }, {
    "source" : "cb9573d4-d7c6-4dbf-85b6-edfb7c5f6742",
    "output" : "bae03932-3849-42b1-8ad8-beda248000a2",
    "target" : "470b1407-d49a-4abc-b5cd-175792a6cf1a",
    "input" : "bc0be9a2-317e-4665-b710-70bdc19a7381"
  }, {
    "source" : "febde8aa-49f8-4058-85d6-fb6659f0149b",
    "output" : "9c8922fd-5c47-4333-b675-7d152635660f",
    "target" : "a1c1d9f4-f675-4ff3-9945-2ffc6b6de994",
    "input" : "268ad63f-b2ba-41a0-b905-d4110928c494"
  }, {
    "source" : "febde8aa-49f8-4058-85d6-fb6659f0149b",
    "output" : "9c8922fd-5c47-4333-b675-7d152635660f",
    "target" : "a1c1d9f4-f675-4ff3-9945-2ffc6b6de994",
    "input" : "edea557f-3459-48ab-b87f-614e63d600c8"
  }, {
    "source" : "febde8aa-49f8-4058-85d6-fb6659f0149b",
    "output" : "23ea43ca-4dbe-4f78-9b57-44de6812c5c4",
    "target" : "cbd6a42e-7d06-4d00-821e-b1f4345f5efe",
    "input" : "dc304b35-c94f-468f-9a1a-cabadce6cac1"
  }, {
    "source" : "febde8aa-49f8-4058-85d6-fb6659f0149b",
    "output" : "c75ca9f4-ff03-418e-96ef-36262962d231",
    "target" : "55eae39a-1f06-44f4-9610-e4373b955c23",
    "input" : "333ddf92-b005-4ccb-8d81-4423e0a3d7ec"
  }, {
    "source" : "febde8aa-49f8-4058-85d6-fb6659f0149b",
    "output" : "c75ca9f4-ff03-418e-96ef-36262962d231",
    "target" : "338e2fa0-d23f-47b3-a443-04a5ccf92b94",
    "input" : "47b57c19-9543-4827-a47f-030c2a8fde5b"
  }, {
    "source" : "a1c1d9f4-f675-4ff3-9945-2ffc6b6de994",
    "output" : "5d8c0988-e99f-4591-85fa-6a9c816c9d10",
    "target" : "766ae56a-60a8-443c-9680-0adf95d290cb",
    "input" : "c1f7b00d-eeef-45c7-ba97-9e18091a93ce"
  }, {
    "source" : "55eae39a-1f06-44f4-9610-e4373b955c23",
    "output" : "54643253-d01f-40e7-b96a-f2e5bacf21c1",
    "target" : "663c60f4-2fea-45f8-88b0-1bc2dbd65bf7",
    "input" : "bb382031-2cfe-4cca-a7f2-6792b409d699"
  }, {
    "source" : "55eae39a-1f06-44f4-9610-e4373b955c23",
    "output" : "6b1fb1ac-ad9d-4a68-8e6a-ca47ece2aa56",
    "target" : "663c60f4-2fea-45f8-88b0-1bc2dbd65bf7",
    "input" : "dc2d3235-9aad-410b-bb8b-4ddd50d8ed0d"
  }, {
    "source" : "d0b5d7c3-158f-4abd-a900-598e93943d17",
    "output" : "7953c7a2-bcbf-461f-af6e-2c82e070e949",
    "target" : "febde8aa-49f8-4058-85d6-fb6659f0149b",
    "input" : "51268cbf-82b9-4ada-9d68-a0fa69368d2d"
  }, {
    "source" : "338e2fa0-d23f-47b3-a443-04a5ccf92b94",
    "output" : "8bbe6a46-8684-4450-975c-51b1e3b9fb2b",
    "target" : "cbd6a42e-7d06-4d00-821e-b1f4345f5efe",
    "input" : "a8e5059d-236e-440b-ad22-f47fcaa0dca4"
  }, {
    "source" : "cbd6a42e-7d06-4d00-821e-b1f4345f5efe",
    "output" : "0949b926-db4b-4e16-9e70-7456304098dd",
    "target" : "55eae39a-1f06-44f4-9610-e4373b955c23",
    "input" : "cbe64f41-eece-4736-be82-cd26a6f502eb"
  }, {
    "source" : "6cce1e36-5c73-4e91-b055-a56e65c1d763",
    "output" : "3a5df8b1-4fbb-4d30-8404-5a11f062b88d",
    "target" : "338e2fa0-d23f-47b3-a443-04a5ccf92b94",
    "input" : "1c19d1bc-dab6-4b07-b1e8-4dc87a71a956"
  }, {
    "source" : "663c60f4-2fea-45f8-88b0-1bc2dbd65bf7",
    "output" : "69d3fe20-2f14-4967-b1c1-64f2cefb1366",
    "target" : "b122b25e-3bf3-4750-9444-34f26237a925",
    "input" : "087f99a9-62ce-4e87-ab28-15ae814c27b2"
  }, {
    "source" : "663c60f4-2fea-45f8-88b0-1bc2dbd65bf7",
    "output" : "31b7fc28-bfc3-4a50-b491-1d7f3dd8fbef",
    "target" : "d0b5d7c3-158f-4abd-a900-598e93943d17",
    "input" : "0ac6e61f-a54c-4dda-a958-a2c85c546df6"
  }, {
    "source" : "55974baf-3717-428b-ab7b-e0ddb3c75a05",
    "output" : "8e7cec3b-b1fe-4578-ba0e-a303e50b7be9",
    "target" : "672c5daf-90d8-4f04-836c-243fb8615d31",
    "input" : "43b17cb3-fc22-4c29-be06-8ecff1e66235"
  }, {
    "source" : "55974baf-3717-428b-ab7b-e0ddb3c75a05",
    "output" : "31fc15a0-71dd-44a5-9f9f-890ae005c9ad",
    "target" : "672c5daf-90d8-4f04-836c-243fb8615d31",
    "input" : "6991766b-166f-40fa-b8bd-5f83b2f41366"
  }, {
    "source" : "306c57dc-d731-43c6-a59e-959ae5d41f34",
    "output" : "330844a5-3b59-479e-8933-40b7fb23c753",
    "target" : "2d9954f0-3463-4b85-b381-ed2d63fe1db7",
    "input" : "4001d1d5-d601-4811-9935-5ebcd84618b5"
  }, {
    "source" : "306c57dc-d731-43c6-a59e-959ae5d41f34",
    "output" : "330844a5-3b59-479e-8933-40b7fb23c753",
    "target" : "2d9954f0-3463-4b85-b381-ed2d63fe1db7",
    "input" : "c35933b4-4190-4a9d-9606-5019280e1c1b"
  }, {
    "source" : "306c57dc-d731-43c6-a59e-959ae5d41f34",
    "output" : "f365bd9b-cfe6-418b-9636-d5be1cba1c9d",
    "target" : "0b1bccf5-873b-43a4-b8c0-6b6f01f9010a",
    "input" : "4d40e1b4-e3a5-4a52-8bc4-737f96cc85cf"
  }, {
    "source" : "306c57dc-d731-43c6-a59e-959ae5d41f34",
    "output" : "deecb646-480c-435f-8642-87ddd8ed44eb",
    "target" : "80eb3460-eb7e-4589-955d-43fe61b55919",
    "input" : "c7547c7f-763c-462d-b9af-62daa650c192"
  }, {
    "source" : "306c57dc-d731-43c6-a59e-959ae5d41f34",
    "output" : "deecb646-480c-435f-8642-87ddd8ed44eb",
    "target" : "64342252-731f-430b-addb-ced4eecbd652",
    "input" : "242de0f0-2297-4285-bfde-7107aaf84ca9"
  }, {
    "source" : "2d9954f0-3463-4b85-b381-ed2d63fe1db7",
    "output" : "bd65a606-7f39-498e-a615-af15b941143b",
    "target" : "29db3508-b008-41be-9e4b-573cdd7a0b86",
    "input" : "3b59d896-4207-4382-b094-3a46c614362b"
  }, {
    "source" : "80eb3460-eb7e-4589-955d-43fe61b55919",
    "output" : "f4a4ecce-dd30-4004-9ac5-ff52bdf8dfc2",
    "target" : "6f651592-d25d-41c5-ae3d-137e205bfc1f",
    "input" : "f616b51f-8563-4222-bda5-a3196b41b83c"
  }, {
    "source" : "80eb3460-eb7e-4589-955d-43fe61b55919",
    "output" : "ac6b74dd-d4d5-4232-a790-909b920872d6",
    "target" : "6f651592-d25d-41c5-ae3d-137e205bfc1f",
    "input" : "db1508de-9316-4d54-b225-03ac7aeea5d0"
  }, {
    "source" : "a727b119-42ef-47a5-82db-ad08e3d52ee7",
    "output" : "b17425da-792e-4483-8b47-fb5ab8bcf943",
    "target" : "80eb3460-eb7e-4589-955d-43fe61b55919",
    "input" : "85309854-d774-4a41-853b-f8b0a7b04264"
  }, {
    "source" : "a90e7aac-293a-450e-a2dd-baa9fe8f6dee",
    "output" : "5fc8d2f5-a579-474e-a124-658e3710083a",
    "target" : "306c57dc-d731-43c6-a59e-959ae5d41f34",
    "input" : "8a6ca357-6bf6-4b10-b467-a125ea4cd573"
  }, {
    "source" : "64342252-731f-430b-addb-ced4eecbd652",
    "output" : "9dae96c0-4b91-4e48-acb4-417dd0a16611",
    "target" : "0b1bccf5-873b-43a4-b8c0-6b6f01f9010a",
    "input" : "5f3f7b3e-e3c9-42bb-9a5a-970b57b7488b"
  }, {
    "source" : "0b1bccf5-873b-43a4-b8c0-6b6f01f9010a",
    "output" : "906f9c42-a087-417a-bdd7-3a2c7ed7171e",
    "target" : "a727b119-42ef-47a5-82db-ad08e3d52ee7",
    "input" : "7c72341d-f5ef-4dde-a903-9a237723f048"
  }, {
    "source" : "56075b58-78e0-4e7e-876d-a1b9d2a1eee9",
    "output" : "4685394d-01cb-409e-902b-75beed95322e",
    "target" : "64342252-731f-430b-addb-ced4eecbd652",
    "input" : "2a97fdc8-1846-4812-a08c-37bb8abdb52a"
  }, {
    "source" : "6f651592-d25d-41c5-ae3d-137e205bfc1f",
    "output" : "63e18bac-2799-4757-8dd7-6bde11ed563e",
    "target" : "85691c05-1432-48f8-81c3-f80c64e40756",
    "input" : "7abd4994-0a2f-493d-99de-a1f950b9f5a0"
  }, {
    "source" : "6f651592-d25d-41c5-ae3d-137e205bfc1f",
    "output" : "1b0c2b34-f2e8-4e2a-97b8-2cd641c5715a",
    "target" : "a90e7aac-293a-450e-a2dd-baa9fe8f6dee",
    "input" : "53c6a659-90b9-4dfe-a70f-5428e2fd9141"
  }, {
    "source" : "672c5daf-90d8-4f04-836c-243fb8615d31",
    "output" : "d6c9744e-9fe7-4241-8caa-b92ba0626ef6",
    "target" : "a90e7aac-293a-450e-a2dd-baa9fe8f6dee",
    "input" : "51fffb79-8f43-46fc-b87d-925ef3134d92"
  }, {
    "source" : "672c5daf-90d8-4f04-836c-243fb8615d31",
    "output" : "abf942bf-2e26-4d27-a050-1eb84063cf45",
    "target" : "a727b119-42ef-47a5-82db-ad08e3d52ee7",
    "input" : "e27aed6c-3a60-490b-9839-290a0f50b213"
  }, {
    "source" : "a3f8e5a7-ef7a-4f44-a7aa-a00b3da68a1b",
    "output" : "d44ca2b0-0f72-492a-a701-1312264f7936",
    "target" : "686d0676-b5a2-4d2f-965d-70430c05c0ae",
    "input" : "c7134c1b-c1e0-46f8-973c-b9df080ad2dc"
  }, {
    "source" : "a3f8e5a7-ef7a-4f44-a7aa-a00b3da68a1b",
    "output" : "d44ca2b0-0f72-492a-a701-1312264f7936",
    "target" : "686d0676-b5a2-4d2f-965d-70430c05c0ae",
    "input" : "8e4c99a7-7a48-453f-ac9b-182ade78cc79"
  }, {
    "source" : "b99209a6-4e51-4de1-8fe9-a532501a7d0f",
    "output" : "8be45d40-808b-4b49-bc8e-53849a385528",
    "target" : "9a147e3b-2160-418a-9edb-1d5dda7e137f",
    "input" : "7131446c-6481-499c-8e9d-374daeb409a1"
  }, {
    "source" : "b99209a6-4e51-4de1-8fe9-a532501a7d0f",
    "output" : "8be45d40-808b-4b49-bc8e-53849a385528",
    "target" : "9a147e3b-2160-418a-9edb-1d5dda7e137f",
    "input" : "253b7245-fdc5-45b4-a7ea-a371cc93c9fd"
  }, {
    "source" : "2ab3ef2f-0ee4-46d0-8c06-62388ae2182f",
    "output" : "1d25f59e-f844-4e51-a6b8-c6037b0ae9ba",
    "target" : "ad442ee6-86e8-413e-8919-953c5c196a42",
    "input" : "a32727d1-ce5d-43c2-a039-fb13fecc3e2b"
  }, {
    "source" : "2ab3ef2f-0ee4-46d0-8c06-62388ae2182f",
    "output" : "1d25f59e-f844-4e51-a6b8-c6037b0ae9ba",
    "target" : "ad442ee6-86e8-413e-8919-953c5c196a42",
    "input" : "e2095afc-1778-4b19-8118-6555af3d58fa"
  }, {
    "source" : "766ae56a-60a8-443c-9680-0adf95d290cb",
    "output" : "9ec978df-54e3-4ab2-a5ba-67fb3354b795",
    "target" : "6cce1e36-5c73-4e91-b055-a56e65c1d763",
    "input" : "f9ae8ba7-0da9-488f-889f-97c90bd07aee"
  }, {
    "source" : "766ae56a-60a8-443c-9680-0adf95d290cb",
    "output" : "9ec978df-54e3-4ab2-a5ba-67fb3354b795",
    "target" : "6cce1e36-5c73-4e91-b055-a56e65c1d763",
    "input" : "5c0a234d-b0e9-4f2f-98bb-3658011f401c"
  }, {
    "source" : "c480e964-c643-493f-acfa-d3e4779c5f49",
    "output" : "eda45f79-3868-493e-9db3-3ad853713c2d",
    "target" : "f56502f3-a4da-40fe-a87c-169f12e8ac5a",
    "input" : "070e4cd0-c6da-485a-8065-3fe0e2738fa3"
  }, {
    "source" : "c480e964-c643-493f-acfa-d3e4779c5f49",
    "output" : "eda45f79-3868-493e-9db3-3ad853713c2d",
    "target" : "f56502f3-a4da-40fe-a87c-169f12e8ac5a",
    "input" : "d6276186-4a2e-475e-a2bb-d478f8f8338e"
  }, {
    "source" : "77796dfa-b35b-497f-b8d6-eb642329d48f",
    "output" : "73d3fa59-27fa-4b4f-8a8d-28fa8d63ee16",
    "target" : "a6b2d463-809b-4a5e-b172-f6217bee22f2",
    "input" : "91dce61a-f43c-4930-aa1f-fa9656dff254"
  }, {
    "source" : "77796dfa-b35b-497f-b8d6-eb642329d48f",
    "output" : "73d3fa59-27fa-4b4f-8a8d-28fa8d63ee16",
    "target" : "a6b2d463-809b-4a5e-b172-f6217bee22f2",
    "input" : "a73ad48a-38b4-4b2c-9d69-a36464516c45"
  }, {
    "source" : "ed464c15-cda5-453c-8f31-cf2770a286bc",
    "output" : "a0c5a885-4c20-4a02-94a9-4091b690d1a3",
    "target" : "205c9e1b-a0a3-4d72-8c4a-3b5d72c1d84c",
    "input" : "0f58e97c-a004-4495-8142-f4989589f5dc"
  }, {
    "source" : "ed464c15-cda5-453c-8f31-cf2770a286bc",
    "output" : "a0c5a885-4c20-4a02-94a9-4091b690d1a3",
    "target" : "205c9e1b-a0a3-4d72-8c4a-3b5d72c1d84c",
    "input" : "30595569-3200-4f4b-8a64-b1bbc46e41ee"
  }, {
    "source" : "3ff58738-0b8b-42a8-9ddc-664f1a14cb13",
    "output" : "77ee67de-0918-4f65-b9ee-99f152d845a7",
    "target" : "c480e964-c643-493f-acfa-d3e4779c5f49",
    "input" : "7d95fbad-a38e-4ac2-8c48-44e27395d788"
  }, {
    "source" : "3549b0c7-cf06-4dbd-8b35-f8600cb8406f",
    "output" : "01524cc9-9456-49f5-a155-61e279374040",
    "target" : "9618781c-edc6-4642-b560-5d05a82f8ab2",
    "input" : "0f9d4f88-249c-4c66-876d-489b08d2e223"
  }, {
    "source" : "f56502f3-a4da-40fe-a87c-169f12e8ac5a",
    "output" : "af6dee9d-96ce-4dd3-bcd1-354f5d1cc66c",
    "target" : "3549b0c7-cf06-4dbd-8b35-f8600cb8406f",
    "input" : "ebd2287f-099a-43cf-96d0-1c57de774f5a"
  }, {
    "source" : "e7c9a145-c3e0-44a8-8af8-c8ff6ab838af",
    "output" : "405787ef-ec70-4968-b5f2-5c4cfbb71781",
    "target" : "3ff58738-0b8b-42a8-9ddc-664f1a14cb13",
    "input" : "e3be3fc9-5262-4d84-91a4-16efb6309038"
  }, {
    "source" : "e7c9a145-c3e0-44a8-8af8-c8ff6ab838af",
    "output" : "405787ef-ec70-4968-b5f2-5c4cfbb71781",
    "target" : "3ff58738-0b8b-42a8-9ddc-664f1a14cb13",
    "input" : "01d5b15c-0294-4064-a41b-91dfe379cc04"
  }, {
    "source" : "e7c9a145-c3e0-44a8-8af8-c8ff6ab838af",
    "output" : "405787ef-ec70-4968-b5f2-5c4cfbb71781",
    "target" : "3549b0c7-cf06-4dbd-8b35-f8600cb8406f",
    "input" : "125e0973-ba8c-4b7b-9a8e-55c0fb45c4b5"
  }, {
    "source" : "85691c05-1432-48f8-81c3-f80c64e40756",
    "output" : "72931c17-fbef-4cf5-a204-69737cd85b76",
    "target" : "5abe9c36-987a-4f65-8738-206c584b7698",
    "input" : "5f99550c-d85c-4438-952c-98e06df3dbcb"
  }, {
    "source" : "85691c05-1432-48f8-81c3-f80c64e40756",
    "output" : "72931c17-fbef-4cf5-a204-69737cd85b76",
    "target" : "5abe9c36-987a-4f65-8738-206c584b7698",
    "input" : "fd6335f0-57a2-4def-9af3-d74dc8e4e9cf"
  }, {
    "source" : "b122b25e-3bf3-4750-9444-34f26237a925",
    "output" : "e965a379-537d-4e41-b9ca-46fc3efe6ab4",
    "target" : "7387d770-dec2-4b73-b37f-f27708ff3f72",
    "input" : "e94a7906-82e0-4128-b839-3a0423b4dbbe"
  }, {
    "source" : "5abe9c36-987a-4f65-8738-206c584b7698",
    "output" : "a8875116-c2e3-4481-b033-2d710e36be89",
    "target" : "b122b25e-3bf3-4750-9444-34f26237a925",
    "input" : "c5c10821-b9fa-4874-bff1-b07d7b01cf2b"
  }, {
    "source" : "60750a4a-72df-4636-bc5b-f0526242fc3c",
    "output" : "48328e7d-2dcb-4de4-8b61-e059bd7b90de",
    "target" : "ad15c2a5-1245-4571-98f9-15debef9afd2",
    "input" : "9ea178f9-db8f-406b-926b-cedc281db550"
  }, {
    "source" : "60750a4a-72df-4636-bc5b-f0526242fc3c",
    "output" : "48328e7d-2dcb-4de4-8b61-e059bd7b90de",
    "target" : "ad15c2a5-1245-4571-98f9-15debef9afd2",
    "input" : "5df4980d-2531-4151-abdc-12665ca3b891"
  }, {
    "source" : "60750a4a-72df-4636-bc5b-f0526242fc3c",
    "output" : "57c15506-3854-43e2-8a52-b4936955890e",
    "target" : "57d98f8a-e0cb-4545-9e48-c5e49fea73f3",
    "input" : "55aeebf8-536b-46e9-8029-c95406dc0120"
  }, {
    "source" : "60750a4a-72df-4636-bc5b-f0526242fc3c",
    "output" : "16773b73-da5a-4b5f-88ab-b8841c2f3aef",
    "target" : "b657c21f-ac8e-4f19-803c-38e1638276dd",
    "input" : "0877d9f4-88d8-461e-9462-3c1754779323"
  }, {
    "source" : "60750a4a-72df-4636-bc5b-f0526242fc3c",
    "output" : "16773b73-da5a-4b5f-88ab-b8841c2f3aef",
    "target" : "dac5e7c6-0480-43f9-bb14-f32e162c85ca",
    "input" : "5248703b-b5a6-4b94-9edb-a87061dae9f5"
  }, {
    "source" : "ad15c2a5-1245-4571-98f9-15debef9afd2",
    "output" : "e0f2ec87-0127-4675-9619-735eefe1a534",
    "target" : "77796dfa-b35b-497f-b8d6-eb642329d48f",
    "input" : "7fadff44-704c-4415-9bb4-f1d3932fb0ad"
  }, {
    "source" : "b657c21f-ac8e-4f19-803c-38e1638276dd",
    "output" : "db8b7c2d-4401-4ba7-bd18-61a3c33cae83",
    "target" : "de79d00a-6f75-4a65-97fa-62cd4b55ecf4",
    "input" : "ba27aaf9-9673-4625-a74d-c4b0f234bcf9"
  }, {
    "source" : "b657c21f-ac8e-4f19-803c-38e1638276dd",
    "output" : "202c5402-aeed-46c6-bccd-d28db0c80251",
    "target" : "de79d00a-6f75-4a65-97fa-62cd4b55ecf4",
    "input" : "15910c0a-816a-4795-a9d2-2c885d21a80c"
  }, {
    "source" : "7387d770-dec2-4b73-b37f-f27708ff3f72",
    "output" : "97a16bd4-5b94-4c2a-8756-cf0702222c56",
    "target" : "60750a4a-72df-4636-bc5b-f0526242fc3c",
    "input" : "f90e6f29-6ef1-4614-a19f-591f00bd0764"
  }, {
    "source" : "dac5e7c6-0480-43f9-bb14-f32e162c85ca",
    "output" : "9d1f2f3e-63d3-4c74-84db-d2dbc0b5efba",
    "target" : "57d98f8a-e0cb-4545-9e48-c5e49fea73f3",
    "input" : "98c3b649-56e7-4d94-8d82-96f6efae542c"
  }, {
    "source" : "57d98f8a-e0cb-4545-9e48-c5e49fea73f3",
    "output" : "cd33c091-a6a1-4a1d-98f7-7c0b5d5cf347",
    "target" : "b657c21f-ac8e-4f19-803c-38e1638276dd",
    "input" : "b249e06b-770c-4b00-a5e8-b04939613ec6"
  }, {
    "source" : "a6b2d463-809b-4a5e-b172-f6217bee22f2",
    "output" : "eb867a97-189e-40b5-a4f5-f02f5a04d2e0",
    "target" : "dac5e7c6-0480-43f9-bb14-f32e162c85ca",
    "input" : "903e6060-3347-48f8-8fae-affb7b6ca911"
  }, {
    "source" : "de79d00a-6f75-4a65-97fa-62cd4b55ecf4",
    "output" : "2793ab95-fe7b-4a3a-985b-7e4c56754632",
    "target" : "853f4bc7-9755-436f-8bcc-49a54b73b2e8",
    "input" : "b8463e3e-b330-42a7-bd8b-bb2d9e5f5756"
  }, {
    "source" : "de79d00a-6f75-4a65-97fa-62cd4b55ecf4",
    "output" : "2793ab95-fe7b-4a3a-985b-7e4c56754632",
    "target" : "64f1afa2-163c-4d0c-994a-4c7f6913ae3d",
    "input" : "7f7bdffc-beac-4d34-a150-5aa91ed520e5"
  }, {
    "source" : "de79d00a-6f75-4a65-97fa-62cd4b55ecf4",
    "output" : "4a6357cb-89bd-49bd-8e1e-c0dc1454e05d",
    "target" : "7387d770-dec2-4b73-b37f-f27708ff3f72",
    "input" : "c0a186e8-f4d2-4142-90f0-2106ca389f7d"
  }, {
    "source" : "cf2a2b81-640c-4947-9023-57bfb8114e16",
    "output" : "1a0508de-5b90-4234-b9c8-a2badbd7ed46",
    "target" : "ed464c15-cda5-453c-8f31-cf2770a286bc",
    "input" : "80e59eff-bd7b-4c9f-9b19-d42939e00996"
  }, {
    "source" : "db67f7f9-265f-441a-9ee5-1f90c25609b5",
    "output" : "9ce53082-cbc4-4c8a-a542-93286be28feb",
    "target" : "cb9573d4-d7c6-4dbf-85b6-edfb7c5f6742",
    "input" : "158a1808-a767-4c98-9b76-e40614dc6ba5"
  }, {
    "source" : "db67f7f9-265f-441a-9ee5-1f90c25609b5",
    "output" : "9ce53082-cbc4-4c8a-a542-93286be28feb",
    "target" : "e7c9a145-c3e0-44a8-8af8-c8ff6ab838af",
    "input" : "8b9e4b30-da26-48f4-8bce-181feaf84b95"
  }, {
    "source" : "205c9e1b-a0a3-4d72-8c4a-3b5d72c1d84c",
    "output" : "cb4a530b-99f8-4b9e-9241-950cfcbfde72",
    "target" : "db67f7f9-265f-441a-9ee5-1f90c25609b5",
    "input" : "bc9d02ab-c8fe-41fa-a3b3-99c1036947bb"
  }, {
    "source" : "64f1afa2-163c-4d0c-994a-4c7f6913ae3d",
    "output" : "5e02af59-e42f-4386-97ab-269c299fcb6f",
    "target" : "cf2a2b81-640c-4947-9023-57bfb8114e16",
    "input" : "9123d960-f595-4226-9cb3-45c1bf551c6b"
  }, {
    "source" : "64f1afa2-163c-4d0c-994a-4c7f6913ae3d",
    "output" : "5e02af59-e42f-4386-97ab-269c299fcb6f",
    "target" : "cf2a2b81-640c-4947-9023-57bfb8114e16",
    "input" : "002c8178-496d-495d-bdcb-58073edab907"
  }, {
    "source" : "64f1afa2-163c-4d0c-994a-4c7f6913ae3d",
    "output" : "5e02af59-e42f-4386-97ab-269c299fcb6f",
    "target" : "db67f7f9-265f-441a-9ee5-1f90c25609b5",
    "input" : "2f77488b-79d4-40c8-a0a3-0db00508afc7"
  } ],
  "bendpoints" : "[{\"source\":\"3549b0c7-cf06-4dbd-8b35-f8600cb8406f\",\"target\":\"9618781c-edc6-4642-b560-5d05a82f8ab2\",\"coordinates\":\"4588:2363\"},{\"source\":\"60750a4a-72df-4636-bc5b-f0526242fc3c\",\"target\":\"dac5e7c6-0480-43f9-bb14-f32e162c85ca\",\"coordinates\":\"2685:1605\"},{\"source\":\"e3076cb2-12d3-4c1c-9125-be8a29b7dba2\",\"target\":\"1041e708-0e55-474f-9b1c-8a9f6321a884\",\"coordinates\":\"760:260\"},{\"source\":\"db67f7f9-265f-441a-9ee5-1f90c25609b5\",\"target\":\"e7c9a145-c3e0-44a8-8af8-c8ff6ab838af\",\"coordinates\":\"3895:2000\"},{\"source\":\"febde8aa-49f8-4058-85d6-fb6659f0149b\",\"target\":\"55eae39a-1f06-44f4-9610-e4373b955c23\",\"coordinates\":\"2390:1300\"},{\"source\":\"306c57dc-d731-43c6-a59e-959ae5d41f34\",\"target\":\"64342252-731f-430b-addb-ced4eecbd652\",\"coordinates\":\"1110:690\"},{\"source\":\"64f1afa2-163c-4d0c-994a-4c7f6913ae3d\",\"target\":\"db67f7f9-265f-441a-9ee5-1f90c25609b5\",\"coordinates\":\"3210:1910\"},{\"source\":\"60750a4a-72df-4636-bc5b-f0526242fc3c\",\"target\":\"b657c21f-ac8e-4f19-803c-38e1638276dd\",\"coordinates\":\"2915:1605\"},{\"source\":\"60750a4a-72df-4636-bc5b-f0526242fc3c\",\"target\":\"57d98f8a-e0cb-4545-9e48-c5e49fea73f3\",\"coordinates\":\"2800:1605\"},{\"source\":\"306c57dc-d731-43c6-a59e-959ae5d41f34\",\"target\":\"80eb3460-eb7e-4589-955d-43fe61b55919\",\"coordinates\":\"1410:690\"},{\"source\":\"dbe88bec-d81c-4a27-8448-42f1900b5dd6\",\"target\":\"9ce122ac-53d5-4da7-8253-953f880883ee\",\"coordinates\":\"1760:1120\"},{\"source\":\"de79d00a-6f75-4a65-97fa-62cd4b55ecf4\",\"target\":\"7387d770-dec2-4b73-b37f-f27708ff3f72\",\"coordinates\":\"3005:1515\"},{\"source\":\"e7c9a145-c3e0-44a8-8af8-c8ff6ab838af\",\"target\":\"3549b0c7-cf06-4dbd-8b35-f8600cb8406f\",\"coordinates\":\"4010:2270\"},{\"source\":\"cb9573d4-d7c6-4dbf-85b6-edfb7c5f6742\",\"target\":\"470b1407-d49a-4abc-b5cd-175792a6cf1a\",\"coordinates\":\"4410:2450\"},{\"source\":\"65a76d99-e481-4589-807b-cfea451d5988\",\"target\":\"50f7364c-cb60-4c22-a158-70b5faf606ef\",\"coordinates\":\"850:170\"},{\"source\":\"de79d00a-6f75-4a65-97fa-62cd4b55ecf4\",\"target\":\"64f1afa2-163c-4d0c-994a-4c7f6913ae3d\",\"coordinates\":\"3095:1695\"},{\"source\":\"306c57dc-d731-43c6-a59e-959ae5d41f34\",\"target\":\"0b1bccf5-873b-43a4-b8c0-6b6f01f9010a\",\"coordinates\":\"1225:690\"},{\"source\":\"febde8aa-49f8-4058-85d6-fb6659f0149b\",\"target\":\"338e2fa0-d23f-47b3-a443-04a5ccf92b94\",\"coordinates\":\"2160:1300\"},{\"source\":\"b6a60a36-cdf6-46a4-8fee-d99e2a7a8e69\",\"target\":\"9618781c-edc6-4642-b560-5d05a82f8ab2\",\"coordinates\":\"4583:2186\"},{\"source\":\"c1cfc5a0-a5e1-447e-985f-d8ee2192ad6d\",\"target\":\"7d0bc860-c353-46da-980b-26ffb474d50f\",\"coordinates\":\"295:8\"},{\"source\":\"c1cfc5a0-a5e1-447e-985f-d8ee2192ad6d\",\"target\":\"55974baf-3717-428b-ab7b-e0ddb3c75a05\",\"coordinates\":\"942:8\"},{\"source\":\"e3076cb2-12d3-4c1c-9125-be8a29b7dba2\",\"target\":\"c92c9604-10d6-4977-8354-eae9d089845e\",\"coordinates\":\"575:260\"},{\"source\":\"b46467c3-7e3a-4755-898f-9f2e8bcd30ce\",\"target\":\"30eab269-13f4-418f-b14e-a2a11e29c40c\",\"coordinates\":\"665:100\"},{\"source\":\"672c5daf-90d8-4f04-836c-243fb8615d31\",\"target\":\"a727b119-42ef-47a5-82db-ad08e3d52ee7\",\"coordinates\":\"1315:530\"},{\"source\":\"663c60f4-2fea-45f8-88b0-1bc2dbd65bf7\",\"target\":\"d0b5d7c3-158f-4abd-a900-598e93943d17\",\"coordinates\":\"2480:1210\"},{\"source\":\"db67f7f9-265f-441a-9ee5-1f90c25609b5\",\"target\":\"cb9573d4-d7c6-4dbf-85b6-edfb7c5f6742\",\"coordinates\":\"4295:2000\"},{\"source\":\"febde8aa-49f8-4058-85d6-fb6659f0149b\",\"target\":\"cbd6a42e-7d06-4d00-821e-b1f4345f5efe\",\"coordinates\":\"2275:1300\"},{\"source\":\"853f4bc7-9755-436f-8bcc-49a54b73b2e8\",\"target\":\"b6a60a36-cdf6-46a4-8fee-d99e2a7a8e69\",\"coordinates\":\"3610:2090\"},{\"source\":\"de79d00a-6f75-4a65-97fa-62cd4b55ecf4\",\"target\":\"853f4bc7-9755-436f-8bcc-49a54b73b2e8\",\"coordinates\":\"3495:1695\"},{\"source\":\"c1cfc5a0-a5e1-447e-985f-d8ee2192ad6d\",\"target\":\"dbe88bec-d81c-4a27-8448-42f1900b5dd6\",\"coordinates\":\"1632:8\"},{\"source\":\"e3076cb2-12d3-4c1c-9125-be8a29b7dba2\",\"target\":\"29d1c39c-85b5-4a95-b7a5-d8d9cc455eea\",\"coordinates\":\"460:260\"},{\"source\":\"65a76d99-e481-4589-807b-cfea451d5988\",\"target\":\"85691c05-1432-48f8-81c3-f80c64e40756\",\"coordinates\":\"2604:352\"},{\"source\":\"6f651592-d25d-41c5-ae3d-137e205bfc1f\",\"target\":\"a90e7aac-293a-450e-a2dd-baa9fe8f6dee\",\"coordinates\":\"1500:600\"}]"
}